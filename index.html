<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MindMap</title>
  <meta name="theme-color" content="#f3f7ff" />
  <style>
    :root{
      --text:#0b1324;
      --stroke:rgba(11,19,36,.12);
      --shadow: 0 18px 60px rgba(10,20,40,.14);
      --grid:rgba(10,20,40,.06);
      --tool:rgba(20,28,40,.90);
      --toolText:rgba(255,255,255,.92);
      --toolStroke:rgba(255,255,255,.10);
      --glass: rgba(255,255,255,.72);
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1000px 700px at 20% 10%, rgba(89,195,255,.28), transparent 58%),
        radial-gradient(900px 650px at 85% 20%, rgba(255,92,122,.20), transparent 60%),
        radial-gradient(1000px 700px at 55% 95%, rgba(60,224,122,.22), transparent 60%),
        linear-gradient(180deg, #f7fbff, #eef4ff 55%, #f8fbff);
      overflow:hidden;
      -webkit-text-size-adjust: 100%;
    }

    .app{ height:100%; display:flex; flex-direction:column; }

    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:100;
      background: var(--glass);
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }

    .btn, select{
      appearance:none;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.70);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.06);
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font: inherit;
      height: 38px;
    }
    .btn:hover, select:hover{ border-color: rgba(89,195,255,.45); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.55); }

    .menuWrap{ position:relative; }
    .drop{
      position:absolute;
      top: 44px;
      right: 0;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(11,19,36,.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 8px;
      display:none;
      min-width: 220px;
      backdrop-filter: blur(10px);
      z-index: 200;
    }
    .drop .item{
      width:100%;
      border: 1px solid rgba(11,19,36,.10);
      background: rgba(255,255,255,.72);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      margin: 6px 0;
      user-select:none;
    }
    .drop .item:hover{ border-color: rgba(89,195,255,.45); }

    input[type="file"]{ display:none; }

    .stageWrap{ flex:1; position:relative; overflow:hidden; }
    .stageWrap::before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 42px 42px, 7px 7px;
      opacity:.75;
      pointer-events:none;
      z-index:0;
    }

    #scene{
      position:absolute;
      inset:0;
      z-index:1;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      overflow:hidden;
    }
    #scene.allowSelect{
      user-select:text;
      -webkit-user-select:text;
    }

    #world{
      position:absolute;
      left:0; top:0;
      transform-origin: 0 0;
      will-change: transform;
      transform: translate3d(0,0,0) scale(1);

      /* –ø–æ–ø—ã—Ç–∫–∞ —Å–¥–µ–ª–∞—Ç—å —Ç–µ–∫—Å—Ç —á—ë—Ç—á–µ –ø—Ä–∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–∏ */
      backface-visibility: hidden;
      -webkit-font-smoothing: antialiased;
      text-rendering: geometricPrecision;
    }

    #links{
      position:absolute;
      left:0; top:0;
      overflow:visible;
      pointer-events:none;
    }
    .link{
      stroke: rgba(30,90,150,.40);
      stroke-width: 2.2;
      fill: none;
    }

    #nodes{
      position:absolute;
      left:0; top:0;
    }

    .node{
      position:absolute;
      border-radius: 16px;
      padding: 10px 12px;
      height: 58px;
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 16px 26px rgba(10,20,40,.14);
      border: 1.2px solid rgba(11,19,36,.18);
      background: rgba(255,255,255,.80);
      cursor: grab;
      user-select:none;
      -webkit-user-select:none;
      min-width: 150px;
      max-width: 360px;
    }
    .node.selected{
      border-color: rgba(89,195,255,.95);
      box-shadow: 0 16px 26px rgba(10,20,40,.14), 0 0 0 3px rgba(89,195,255,.18) inset;
    }
    .node:active{ cursor: grabbing; }

    .node .text{
      flex:1 1 auto;
      line-height:1.15;
      overflow:hidden;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
      word-break: break-word;
      cursor: default;
      text-align: center;
      font-weight: 400;
      font-style: normal;
      width:100%;
    }

    .node.editing{
      cursor:text;
      user-select:text;
      -webkit-user-select:text;
    }
    .node.editing .text{
      outline:none;
      cursor:text;
      user-select:text;
      -webkit-user-select:text;
      -webkit-line-clamp: unset;
      display:block;
      overflow: visible;
      white-space: pre-wrap;
    }

    /* –ö–Ω–æ–ø–∫–∞ ‚ãØ ‚Äî —Ç–µ–ø–µ—Ä—å –≤–Ω—É—Ç—Ä–∏ WORLD, –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å —É–∑–ª–æ–º */
    .dotsBtn{
      position:absolute;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(255,255,255,.90);
      border: 2px solid rgba(11,19,36,.22);
      box-shadow: 0 12px 26px rgba(10,20,40,.16);
      color: rgba(11,19,36,.80);
      display:none;
      align-items:center;
      justify-content:center;
      font-size: 14px;
      line-height: 1;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
      backdrop-filter: blur(10px);
      z-index: 40;
    }
    .dotsBtn:hover{
      box-shadow: 0 12px 26px rgba(10,20,40,.16), 0 0 0 3px rgba(89,195,255,.16);
    }

    /* –ú–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π ‚Äî —Ç–æ–∂–µ –≤–Ω—É—Ç—Ä–∏ WORLD */
    .ctx{
      position:absolute;
      z-index:50;
      background: var(--tool);
      color: var(--toolText);
      border:1px solid var(--toolStroke);
      border-radius:14px;
      box-shadow: var(--shadow);
      display:none;
      gap:6px;
      padding:8px;
      align-items:center;
      user-select:none;
      -webkit-user-select:none;
      backdrop-filter: blur(10px);
    }
    .ctx .cbtn{
      width:34px; height:34px;
      display:flex; align-items:center; justify-content:center;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      font-size:16px;
    }
    .ctx .cbtn:hover{ border-color: rgba(89,195,255,.50); }
    .ctx .cbtn.on{
      border-color: rgba(89,195,255,.70);
      box-shadow: 0 0 0 2px rgba(89,195,255,.18) inset;
    }
    .ctx .csep{ width:1px; height:22px; background: rgba(255,255,255,.12); margin:0 2px; }
    .ctx .label{ font-size:12px; color: rgba(255,255,255,.70); padding:0 6px 0 2px; }

    .emojiPop{
      position:absolute;
      z-index:60;
      display:none;
      width: 308px;
      max-height: 220px;
      overflow:auto;
      background: rgba(20,28,40,.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      box-shadow: var(--shadow);
      padding:10px;
      backdrop-filter: blur(10px);
      overscroll-behavior: contain;
      scrollbar-gutter: stable both-edges;
    }
    .emojiPop::-webkit-scrollbar{ width: 10px; height: 10px; }
    .emojiPop::-webkit-scrollbar-track{
      background: rgba(255,255,255,.06);
      border-radius: 12px;
      margin: 8px;
    }
    .emojiPop::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.18);
      border-radius: 12px;
      border: 2px solid rgba(20,28,40,.92);
    }
    .emojiPop::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.26); }
    .emojiPop{ scrollbar-color: rgba(255,255,255,.22) rgba(255,255,255,.06); scrollbar-width: thin; }

    .emojiGrid{
      display:grid;
      grid-template-columns: repeat(10, 1fr);
      gap:6px;
    }
    .emojiCell{
      width: 26px; height: 26px;
      display:flex; align-items:center; justify-content:center;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      font-size:16px;
      user-select:none;
      -webkit-user-select:none;
    }
    .emojiCell:hover{ border-color: rgba(89,195,255,.50); }

    .collapseDot{
      position:absolute;
      width: 18px; height: 18px;
      border-radius: 999px;
      box-shadow: 0 10px 18px rgba(10,20,40,.12);
      cursor: pointer;
      user-select:none;
      -webkit-user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,.90);
      border: 2px solid rgba(11,19,36,.22);
      z-index: 30;
    }
    .collapseDot .inner{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: transparent;
      opacity: .35;
    }
    .collapseDot.collapsed .inner{ opacity: .70; }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(255,255,255,.72);
      border:1px solid rgba(11,19,36,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(11,19,36,.86);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(720px, calc(100% - 24px));
      z-index:110;
    }
    .toast.show{ opacity:1; }
  </style>
</head>

<body>
<div class="app">
  <header id="topbar">
    <select id="projectSelect" title="–ú–∞–π–Ω–¥–º—ç–ø"></select>
    <button class="btn primary" id="projNew">+ –ù–æ–≤—ã–π</button>

    <div class="menuWrap">
      <button class="btn" id="downloadBtn">–°–∫–∞—á–∞—Ç—å ‚ñæ</button>
      <div class="drop" id="downloadDrop">
        <div class="item" id="exportOneBtn"><span>–≠–∫—Å–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã</span><span>JSON</span></div>
        <label class="item" for="importOne"><span>–ò–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã</span><span>JSON</span></label>
        <div class="item" id="exportAllBtn"><span>–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö</span><span>JSON</span></div>
        <label class="item" for="importAll"><span>–ò–º–ø–æ—Ä—Ç –≤—Å–µ—Ö</span><span>JSON</span></label>
      </div>
    </div>

    <input id="importOne" type="file" accept="application/json" />
    <input id="importAll" type="file" accept="application/json" />
  </header>

  <div class="stageWrap" id="wrap">
    <div id="scene">
      <div id="world">
        <svg id="links" xmlns="http://www.w3.org/2000/svg"></svg>
        <div id="nodes"></div>

        <!-- –ö–Ω–æ–ø–∫–∞ ‚ãØ –∏ –º–µ–Ω—é –ª–µ–∂–∞—Ç –í–ù–£–¢–†–ò world, –∑–Ω–∞—á–∏—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä—É—é—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å –∫–∞—Ä—Ç–æ–π -->
        <div class="dotsBtn" id="dotsBtn" title="–ú–µ–Ω—é">‚ãØ</div>

        <div class="ctx" id="ctx">
          <div class="label">–£–∑–µ–ª</div>
          <div class="cbtn" id="ctxChild" title="–î–æ—á–µ—Ä–Ω–∏–π">‚Ü≥</div>
          <div class="cbtn" id="ctxSibling" title="–°–æ—Å–µ–¥–Ω–∏–π">‚Ü¶</div>
          <div class="cbtn" id="ctxRename" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úèÔ∏è</div>

          <div class="csep"></div>

          <div class="cbtn" id="ctxBold" title="–ñ–∏—Ä–Ω—ã–π"><b>B</b></div>
          <div class="cbtn" id="ctxItalic" title="–ö—É—Ä—Å–∏–≤"><i>I</i></div>

          <div class="csep"></div>

          <div class="cbtn" id="ctxAlignL" title="–ü–æ –ª–µ–≤–æ–º—É">‚á§</div>
          <div class="cbtn" id="ctxAlignC" title="–ü–æ —Ü–µ–Ω—Ç—Ä—É">‚â°</div>
          <div class="cbtn" id="ctxAlignR" title="–ü–æ –ø—Ä–∞–≤–æ–º—É">‚á•</div>

          <div class="csep"></div>

          <div class="cbtn" id="ctxColor" title="–¶–≤–µ—Ç">üé®</div>
          <div class="cbtn" id="ctxEmoji" title="–≠–º–æ–¥–∑–∏ –≤ —Ç–µ–∫—Å—Ç">üòä</div>
          <div class="cbtn" id="ctxCollapse" title="–°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å">‚§µÔ∏è</div>

          <div class="csep"></div>

          <div class="cbtn" id="ctxDelete" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</div>
          <div class="cbtn" id="ctxClose" title="–ó–∞–∫—Ä—ã—Ç—å">‚úñ</div>
        </div>

        <div class="emojiPop" id="emojiPop">
          <div class="emojiGrid" id="emojiGrid"></div>
        </div>

      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  const STORE_KEY = "mindmap_projects_v7";

  const PALETTE = [
    {name:"Sky",    fill:"rgba(89,195,255,.20)", stroke:"rgba(33,140,210,.62)"},
    {name:"Rose",   fill:"rgba(255,92,122,.18)", stroke:"rgba(230,70,95,.64)"},
    {name:"Lime",   fill:"rgba(60,224,122,.18)", stroke:"rgba(30,170,85,.62)"},
    {name:"Amber",  fill:"rgba(255,209,102,.20)", stroke:"rgba(205,150,40,.64)"},
    {name:"Violet", fill:"rgba(176,122,255,.18)", stroke:"rgba(135,90,210,.64)"},
    {name:"Slate",  fill:"rgba(255,255,255,.80)", stroke:"rgba(11,19,36,.18)"}
  ];

  const EMOJIS = [
    "üí°","‚úÖ","üéØ","üìå","üß†","‚ö°","üß©","üî•","üìé","üîó","‚≠ê","üìù","üìö","üß™","üêû","üß≠",
    "üöÄ","üß±","üóÇÔ∏è","üìà","üìä","üì£","üß∞","ü™Ñ","üíé","üóùÔ∏è","üåø","‚ùó","‚ùì","üü¢","üü°","üî¥","üü£","üîµ"
  ];

  const wrap = document.getElementById("wrap");
  const topbar = document.getElementById("topbar");
  const scene = document.getElementById("scene");
  const world = document.getElementById("world");
  const linksSvg = document.getElementById("links");
  const nodesLayer = document.getElementById("nodes");
  const toast = document.getElementById("toast");

  const dotsBtn = document.getElementById("dotsBtn");
  const ctx = document.getElementById("ctx");
  const emojiPop = document.getElementById("emojiPop");
  const emojiGrid = document.getElementById("emojiGrid");

  const projectSelect = document.getElementById("projectSelect");
  const importOne = document.getElementById("importOne");
  const importAll = document.getElementById("importAll");

  const downloadBtn = document.getElementById("downloadBtn");
  const downloadDrop = document.getElementById("downloadDrop");
  const exportOneBtn = document.getElementById("exportOneBtn");
  const exportAllBtn = document.getElementById("exportAllBtn");

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);
  const nowTs = () => Date.now();

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 1400);
  }

  // –∏–∑–º–µ—Ä–µ–Ω–∏–µ —à–∏—Ä–∏–Ω—ã —Ç–µ–∫—Å—Ç–∞ -> —à–∏—Ä–∏–Ω–∞ —É–∑–ª–∞
  const measureCanvas = document.createElement("canvas");
  const mctx = measureCanvas.getContext("2d");
  const FONT = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
  function measureNode(text){
    mctx.font = FONT;
    const t = (text || "").trim() || "–ò–¥–µ—è";
    const raw = mctx.measureText(t).width;
    const minW = 150;
    const maxW = 360;
    const w = Math.max(minW, Math.min(maxW, Math.ceil(raw + 48)));
    const h = 58;
    return {w,h};
  }

  let store = null;
  let active = null;
  let map = null;

  let selectedId = null;
  let editingId = null;

  let ctxOpen = false;
  let emojiOpen = false;

  // --- VIEW / ZOOM ---
  const DRAG_THRESHOLD = 6;
  let drag = null;

  function saveStore(){
    try{ localStorage.setItem(STORE_KEY, JSON.stringify(store)); }catch(e){}
  }
  function loadStore(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (raw){
        const obj = JSON.parse(raw);
        if (obj && obj.projects && typeof obj.projects === "object") return obj;
      }
    }catch(e){}
    return null;
  }

  function normalizeMapData(data){
    data.view ||= {x:24,y:24,k:1};
    data.nodes ||= [];
    data.links ||= [];
    data.nodes.forEach(n => {
      n.text ||= "–ò–¥–µ—è";
      if ("icon" in n) delete n.icon;

      n.style ||= { fill: PALETTE[0].fill, stroke: PALETTE[0].stroke };
      n.childColorNext ||= 0;
      n.parentId = n.parentId || null;
      n.collapsed = !!n.collapsed;

      n.fmt ||= { bold:false, italic:false, align:"center" };
      if (!n.fmt.align) n.fmt.align = "center";

      const m = measureNode(n.text);
      n.w = m.w; n.h = m.h;
    });
    data.links = data.links.filter(l => l && l.a && l.b && l.a !== l.b);
    return data;
  }

  function createEmptyProject(name="–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø"){
    const id = uid();
    const data = normalizeMapData({ nodes: [], links: [], view:{x:24,y:24,k:1} });

    const centerId = uid();
    const m = measureNode("–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è");
    data.nodes.push({
      id:centerId, x:260, y:180, w:m.w, h:m.h,
      text:"–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è",
      style:{fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
      childColorNext:0,
      parentId:null,
      collapsed:false,
      fmt:{bold:false, italic:false, align:"center"}
    });

    const p = { id, name, createdAt: nowTs(), updatedAt: nowTs(), data };
    store.projects[id] = p;
    store.activeId = id;
    saveStore();
    return p;
  }

  function rebuildProjectSelect(){
    projectSelect.innerHTML = "";
    const ids = Object.keys(store.projects)
      .map(id => store.projects[id])
      .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0))
      .map(p => p.id);

    for (const id of ids){
      const p = store.projects[id];
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è";
      if (id === store.activeId) opt.selected = true;
      projectSelect.appendChild(opt);
    }
  }

  function setActiveProject(id){
    const p = store.projects[id];
    if (!p) return;
    store.activeId = id;
    active = p;
    map = normalizeMapData(JSON.parse(JSON.stringify(p.data)));
    selectedId = null;
    editingId = null;
    drag = null;
    closeAllPopups(true);
    saveStore();
    rebuildProjectSelect();
    renderAll();
  }

  function commitMap(){
    if (!active) return;
    active.updatedAt = nowTs();
    active.data = JSON.parse(JSON.stringify(map));
    saveStore();
  }
  function autosave(){
    clearTimeout(autosave._t);
    autosave._t = setTimeout(() => commitMap(), 250);
  }

  function getNode(id){ return map.nodes.find(n => n.id === id); }
  function childrenOf(id){ return map.nodes.filter(n => n.parentId === id).map(n => n.id); }

  function isHiddenByCollapse(nodeId){
    let cur = getNode(nodeId);
    while(cur && cur.parentId){
      const p = getNode(cur.parentId);
      if (p && p.collapsed) return true;
      cur = p;
    }
    return false;
  }

  function addLink(a,b){
    if (!a || !b || a===b) return;
    const exists = map.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    map.links.push({ id: uid(), a, b });
  }

  function addNodeAt(x,y, text="–ù–æ–≤–∞—è –∏–¥–µ—è", style=PALETTE[0]){
    const m = measureNode(text);
    const id = uid();
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text,
      style: {fill: style.fill, stroke: style.stroke},
      childColorNext: 0,
      parentId: null,
      collapsed: false,
      fmt:{bold:false, italic:false, align:"center"}
    });
    selectedId = id;
    ctxOpen = false;
    emojiOpen = false;
    autosave();
    renderAll();
    return id;
  }

  function addChildFrom(parentId){
    const parent = getNode(parentId);
    if (!parent) return null;

    const idx = ((parent.childColorNext||0) + 1) % PALETTE.length;
    parent.childColorNext = (parent.childColorNext||0) + 1;
    const style = PALETTE[idx];

    const x = parent.x + parent.w + 140;
    const y = parent.y + (Math.random()*70 - 35);

    const id = uid();
    const m = measureNode("–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è");
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text:"–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è",
      style:{fill: style.fill, stroke: style.stroke},
      childColorNext: 0,
      parentId: parentId,
      collapsed:false,
      fmt:{bold:false, italic:false, align:"center"}
    });
    addLink(parentId, id);

    selectedId = id;
    ctxOpen = false;
    emojiOpen = false;
    autosave();
    renderAll();
    return id;
  }

  function addSiblingFrom(nodeId){
    const n = getNode(nodeId);
    if (!n) return null;

    const parentId = n.parentId || null;
    const x = n.x;
    const y = n.y + n.h + 18;

    const id = uid();
    const m = measureNode("–ù–æ–≤–∞—è –∏–¥–µ—è");
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text:"–ù–æ–≤–∞—è –∏–¥–µ—è",
      style: n.style ? {fill:n.style.fill, stroke:n.style.stroke} : {fill:PALETTE[0].fill, stroke:PALETTE[0].stroke},
      childColorNext: 0,
      parentId,
      collapsed:false,
      fmt:{bold:false, italic:false, align:"center"}
    });
    if (parentId) addLink(parentId, id);

    selectedId = id;
    ctxOpen = false;
    emojiOpen = false;
    autosave();
    renderAll();
    return id;
  }

  function deleteSubtree(id){
    const ids = new Set();
    const stack = [id];
    while(stack.length){
      const v = stack.pop();
      ids.add(v);
      for (const c of childrenOf(v)) stack.push(c);
    }
    map.nodes = map.nodes.filter(n => !ids.has(n.id));
    map.links = map.links.filter(l => !ids.has(l.a) && !ids.has(l.b));
    if (selectedId && ids.has(selectedId)) selectedId = null;
    closeAllPopups(true);
    autosave();
    renderAll();
  }

  function toggleCollapse(id){
    const n = getNode(id);
    if (!n) return;
    n.collapsed = !n.collapsed;
    autosave();
    renderAll();
  }

  // --- transform helpers ---
  function applyTransform(){
    // –æ–∫—Ä—É–≥–ª—è–µ–º translate, –∏ –∑—É–º –¥–µ–ª–∞–µ–º "—Å—Ç—É–ø–µ–Ω—å–∫–∞–º–∏" –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –º—ã–ª–∞
    const v = map.view;
    const tx = Math.round(v.x);
    const ty = Math.round(v.y);
    const k = v.k;
    world.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${k})`;
  }

  function clientToWorld(cx, cy){
    const r = scene.getBoundingClientRect();
    const v = map.view;
    return {
      x: (cx - r.left - v.x) / v.k,
      y: (cy - r.top  - v.y) / v.k
    };
  }

  function edgePoint(fromNode, toNode){
    const cx = fromNode.x + fromNode.w/2;
    const cy = fromNode.y + fromNode.h/2;
    const tx = toNode.x + toNode.w/2;
    const ty = toNode.y + toNode.h/2;
    let dx = tx - cx, dy = ty - cy;
    if (dx === 0 && dy === 0) { dx = 1; dy = 0; }

    const hw = fromNode.w/2, hh = fromNode.h/2;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const sx = adx ? (hw / adx) : Infinity;
    const sy = ady ? (hh / ady) : Infinity;
    const t = Math.min(sx, sy);
    return { x: cx + dx * t, y: cy + dy * t };
  }

  function drawLinks(){
    const maxX = Math.max(2000, ...map.nodes.map(n => n.x + n.w + 300));
    const maxY = Math.max(1400, ...map.nodes.map(n => n.y + n.h + 300));
    linksSvg.setAttribute("width", maxX);
    linksSvg.setAttribute("height", maxY);

    linksSvg.innerHTML = "";
    for (const l of map.links){
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) continue;
      if (isHiddenByCollapse(a.id) || isHiddenByCollapse(b.id)) continue;

      const p1 = edgePoint(a, b);
      const p2 = edgePoint(b, a);
      const dx = p2.x - p1.x;
      const c1x = p1.x + dx * 0.33;
      const c2x = p1.x + dx * 0.66;
      const d = `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("class","link");
      linksSvg.appendChild(path);
    }
  }

  function renderSelectionOnly(){
    [...nodesLayer.querySelectorAll(".node")].forEach(el => {
      el.classList.toggle("selected", el.getAttribute("data-id") === selectedId);
    });
  }

  function applyNodeFmt(nodeEl, n){
    const textEl = nodeEl.querySelector(".text");
    const fmt = n.fmt || {bold:false, italic:false, align:"center"};
    textEl.style.fontWeight = fmt.bold ? "700" : "400";
    textEl.style.fontStyle = fmt.italic ? "italic" : "normal";
    textEl.style.textAlign = fmt.align || "center";
  }

  function closeAllPopups(hard){
    ctxOpen = false;
    emojiOpen = false;
    ctx.style.display = "none";
    emojiPop.style.display = "none";
    dotsBtn.style.display = "none";
    if (hard) selectedId = null;
  }

  function updateCtxToggles(){
    const n = selectedId ? getNode(selectedId) : null;
    if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"center"};

    document.getElementById("ctxBold").classList.toggle("on", !!n.fmt.bold);
    document.getElementById("ctxItalic").classList.toggle("on", !!n.fmt.italic);

    document.getElementById("ctxAlignL").classList.toggle("on", (n.fmt.align||"center")==="left");
    document.getElementById("ctxAlignC").classList.toggle("on", (n.fmt.align||"center")==="center");
    document.getElementById("ctxAlignR").classList.toggle("on", (n.fmt.align||"center")==="right");
  }

  function positionDotsAndMenus(){
    // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º ‚ãØ –¢–û–õ–¨–ö–û –∫–æ–≥–¥–∞ —É–∑–µ–ª –≤—ã–±—Ä–∞–Ω
    if (!selectedId) {
      dotsBtn.style.display = "none";
      ctx.style.display = "none";
      emojiPop.style.display = "none";
      return;
    }
    const n = getNode(selectedId);
    if (!n || isHiddenByCollapse(selectedId)) {
      dotsBtn.style.display = "none";
      ctx.style.display = "none";
      emojiPop.style.display = "none";
      return;
    }

    // ‚ãØ –ø–æ —Ü–µ–Ω—Ç—Ä—É —Å–Ω–∏–∑—É —É–∑–ª–∞, –ø–æ—á—Ç–∏ –≤–ø–ª–æ—Ç–Ω—É—é
    const dotW = 18, dotH = 18, gap = 2;
    const tx = n.x + n.w/2 - dotW/2;
    const ty = n.y + n.h + gap;

    const stroke = (n.style && n.style.stroke) ? n.style.stroke : "rgba(11,19,36,.22)";
    dotsBtn.style.borderColor = stroke;
    dotsBtn.style.color = stroke;

    dotsBtn.style.left = tx + "px";
    dotsBtn.style.top  = ty + "px";
    dotsBtn.style.display = "flex";

    // –º–µ–Ω—é ‚Äî —Å—Ä–∞–∑—É –ø–æ–¥ ‚ãØ, –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ
    if (ctxOpen){
      const ctxW = 520;
      const ctxH = 52;
      const gap2 = 6;

      let cx = n.x + n.w/2 - ctxW/2;
      cx = Math.max(10, cx); // –≤ world-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö –ø—Ä–æ—Å—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–∏–º —Å–ª–µ–≤–∞
      const cy = ty + dotH + gap2;

      ctx.style.left = cx + "px";
      ctx.style.top  = cy + "px";
      ctx.style.display = "flex";
    } else {
      ctx.style.display = "none";
      emojiOpen = false;
      emojiPop.style.display = "none";
    }

    if (emojiOpen){
      // emoji –ø–æ–¥ –º–µ–Ω—é
      const anchorTop = parseFloat(ctx.style.top || (ty + dotH + 6));
      const anchorLeft = parseFloat(ctx.style.left || (n.x));
      const ey = anchorTop + 56;
      const ex = anchorLeft;
      emojiPop.style.left = ex + "px";
      emojiPop.style.top  = ey + "px";
      emojiPop.style.display = "block";
    } else {
      emojiPop.style.display = "none";
    }

    updateCtxToggles();
  }

  function renderNodes(){
    nodesLayer.innerHTML = "";

    for (const n of map.nodes){
      if (isHiddenByCollapse(n.id)) continue;

      const div = document.createElement("div");
      div.className = "node" + (n.id === selectedId ? " selected" : "");
      div.style.left = n.x + "px";
      div.style.top  = n.y + "px";
      div.style.width = n.w + "px";
      div.style.height = n.h + "px";
      div.style.background = n.style?.fill || "rgba(255,255,255,.80)";
      div.style.borderColor = n.style?.stroke || "rgba(11,19,36,.18)";
      div.setAttribute("data-id", n.id);

      const text = document.createElement("div");
      text.className = "text";
      text.textContent = n.text || "";
      div.appendChild(text);

      applyNodeFmt(div, n);

      // selection
      div.addEventListener("pointerdown", (e) => {
        if (editingId) return;
        e.preventDefault();
        selectedId = n.id;
        renderSelectionOnly();
        // ‚ãØ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –ø–æ –∫–ª–∏–∫—É –Ω–∞ —É–∑–µ–ª
        positionDotsAndMenus();
      }, {passive:false});

      // drag node
      div.addEventListener("pointerdown", (e) => {
        if (editingId) return;
        drag = {
          kind: "node",
          nodeId: n.id,
          pointerId: e.pointerId,
          sx: e.clientX, sy: e.clientY,
          moved: false,
          baseX: n.x, baseY: n.y
        };
        div.setPointerCapture(e.pointerId);
      }, {passive:false});

      div.addEventListener("pointermove", (e) => {
        if (!drag || drag.kind !== "node" || drag.pointerId !== e.pointerId || drag.nodeId !== n.id) return;

        const dx = e.clientX - drag.sx;
        const dy = e.clientY - drag.sy;
        const dist = Math.hypot(dx, dy);
        if (!drag.moved && dist > 6) drag.moved = true;
        if (!drag.moved) return;

        const node = getNode(drag.nodeId);
        if (!node) return;

        node.x = drag.baseX + dx / map.view.k;
        node.y = drag.baseY + dy / map.view.k;

        div.style.left = node.x + "px";
        div.style.top  = node.y + "px";

        const dot = nodesLayer.querySelector(`.collapseDot[data-dot-for="${CSS.escape(node.id)}"]`);
        if (dot){
          dot.style.left = (node.x + node.w + 10) + "px";
          dot.style.top  = (node.y + node.h/2 - 9) + "px";
        }

        drawLinks();
        positionDotsAndMenus();
        autosave();
      });

      function endNodeDrag(e){
        if (drag && drag.kind === "node" && drag.pointerId === e.pointerId){
          drag = null;
        }
      }
      div.addEventListener("pointerup", endNodeDrag);
      div.addEventListener("pointercancel", endNodeDrag);
      div.addEventListener("lostpointercapture", endNodeDrag);

      // double/triple click logic
      const TAP_WINDOW = 420;
      if (!renderNodes._tap) renderNodes._tap = { id:null, count:0, t:0, timer:null };
      const tap = renderNodes._tap;

      div.addEventListener("pointerup", (e) => {
        const moved = !!(drag && drag.kind === "node" && drag.pointerId === e.pointerId && drag.moved);
        if (editingId || moved) return;

        const now = Date.now();
        const same = (tap.id === n.id) && (now - tap.t <= TAP_WINDOW);
        tap.id = n.id;
        tap.t = now;
        tap.count = same ? (tap.count + 1) : 1;

        if (tap.timer) clearTimeout(tap.timer);
        tap.timer = setTimeout(() => {
          if (tap.id !== n.id) return;

          if (tap.count === 2){
            const childId = addChildFrom(n.id);
            if (childId) beginEdit(childId, true);
          } else if (tap.count >= 3){
            beginEdit(n.id, true);
          }

          tap.id = null; tap.count = 0; tap.timer = null;
        }, TAP_WINDOW + 30);
      });

      nodesLayer.appendChild(div);

      // collapse dot
      const kids = childrenOf(n.id);
      if (kids.length){
        const dot = document.createElement("div");
        dot.className = "collapseDot" + (n.collapsed ? " collapsed" : "");
        dot.setAttribute("data-dot-for", n.id);
        dot.style.left = (n.x + n.w + 10) + "px";
        dot.style.top  = (n.y + n.h/2 - 9) + "px";

        const stroke = (n.style && n.style.stroke) ? n.style.stroke : "rgba(11,19,36,.22)";
        dot.style.borderColor = stroke;

        const inner = document.createElement("div");
        inner.className = "inner";
        inner.style.background = stroke;
        dot.appendChild(inner);

        dot.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          toggleCollapse(n.id);
        });

        nodesLayer.appendChild(dot);
      }
    }
  }

  function renderAll(){
    applyTransform();
    drawLinks();
    renderNodes();
    positionDotsAndMenus();
  }

  // ---- Editing ----
  function selectAllIn(el){
    const range = document.createRange();
    range.selectNodeContents(el);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function beginEdit(id, selectAll=false){
    if (editingId) return;
    const nodeEl = nodesLayer.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
    const n = getNode(id);
    if (!nodeEl || !n) return;

    editingId = id;
    scene.classList.add("allowSelect");
    nodeEl.classList.add("editing");

    const textEl = nodeEl.querySelector(".text");
    textEl.contentEditable = "true";
    textEl.textContent = n.text || "";
    textEl.focus();

    if (selectAll) selectAllIn(textEl);

    const finish = (saveChanges) => {
      textEl.removeEventListener("keydown", onKey);
      textEl.removeEventListener("blur", onBlur);

      if (saveChanges){
        const val = (textEl.textContent || "").trim();
        n.text = val || "–ò–¥–µ—è";
        const m = measureNode(n.text);
        n.w = m.w; n.h = m.h;
      } else {
        textEl.textContent = n.text || "–ò–¥–µ—è";
      }

      textEl.contentEditable = "false";
      nodeEl.classList.remove("editing");
      editingId = null;

      scene.classList.remove("allowSelect");
      autosave();
      renderAll();
    };

    const onKey = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "a"){
        e.preventDefault();
        selectAllIn(textEl);
        return;
      }
      if (e.key === "Enter"){ e.preventDefault(); textEl.blur(); }
      if (e.key === "Escape"){ e.preventDefault(); finish(false); }
      e.stopPropagation();
    };
    const onBlur = () => finish(true);

    textEl.addEventListener("keydown", onKey);
    textEl.addEventListener("blur", onBlur);
  }

  function insertEmojiToNode(nodeId, emoji){
    const n = getNode(nodeId);
    if (!n) return;
    const t = (n.text || "").trim();
    n.text = t ? `${emoji} ${t}` : `${emoji}`;
    const m = measureNode(n.text);
    n.w = m.w; n.h = m.h;
    autosave();
    renderAll();
  }

  // ---- Context menu actions ----
  document.getElementById("ctxChild").onclick = () => {
    if (!selectedId) return;
    const id = addChildFrom(selectedId);
    if (id) beginEdit(id, true);
  };
  document.getElementById("ctxSibling").onclick = () => {
    if (!selectedId) return;
    const id = addSiblingFrom(selectedId);
    if (id) beginEdit(id, true);
  };
  document.getElementById("ctxRename").onclick = () => { if (selectedId) beginEdit(selectedId, true); };

  document.getElementById("ctxBold").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"center"};
    n.fmt.bold = !n.fmt.bold;
    autosave(); renderAll();
  };
  document.getElementById("ctxItalic").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"center"};
    n.fmt.italic = !n.fmt.italic;
    autosave(); renderAll();
  };
  document.getElementById("ctxAlignL").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"center"};
    n.fmt.align = "left";
    autosave(); renderAll();
  };
  document.getElementById("ctxAlignC").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"center"};
    n.fmt.align = "center";
    autosave(); renderAll();
  };
  document.getElementById("ctxAlignR").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"center"};
    n.fmt.align = "right";
    autosave(); renderAll();
  };

  document.getElementById("ctxColor").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    const i = PALETTE.findIndex(p => p.fill === n.style.fill && p.stroke === n.style.stroke);
    const next = PALETTE[(Math.max(0,i)+1) % PALETTE.length];
    n.style = {fill: next.fill, stroke: next.stroke};
    autosave(); renderAll();
  };

  document.getElementById("ctxEmoji").onclick = () => {
    if (!selectedId) return;
    emojiOpen = !emojiOpen;
    positionDotsAndMenus();
  };

  document.getElementById("ctxCollapse").onclick = () => { if (selectedId) toggleCollapse(selectedId); };
  document.getElementById("ctxDelete").onclick = () => { if (selectedId) deleteSubtree(selectedId); };
  document.getElementById("ctxClose").onclick = () => {
    ctxOpen = false;
    emojiOpen = false;
    positionDotsAndMenus();
  };

  function buildEmojiGrid(){
    emojiGrid.innerHTML = "";
    for (const em of EMOJIS){
      const cell = document.createElement("div");
      cell.className = "emojiCell";
      cell.textContent = em;
      cell.onclick = () => {
        if (!selectedId) return;
        insertEmojiToNode(selectedId, em);
        emojiOpen = false;
        positionDotsAndMenus();
      };
      emojiGrid.appendChild(cell);
    }
  }
  buildEmojiGrid();

  // dots click -> open ctx
  dotsBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    ctxOpen = !ctxOpen;
    if (!ctxOpen) emojiOpen = false;
    positionDotsAndMenus();
  });

  // click outside -> close ctx/emoji (–Ω–µ —Å–Ω–∏–º–∞–µ–º selection, –ø—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é)
  document.addEventListener("pointerdown", (e) => {
    if (e.target.closest("#ctx") || e.target.closest("#dotsBtn") || e.target.closest("#emojiPop")) return;
    if (ctxOpen || emojiOpen){
      ctxOpen = false;
      emojiOpen = false;
      positionDotsAndMenus();
    }
  });

  // ---- Scene pan/zoom & create ----
  scene.addEventListener("pointerdown", (e) => {
    const onUi = !!e.target.closest(".node") || !!e.target.closest(".collapseDot") || !!e.target.closest("#ctx") || !!e.target.closest("#dotsBtn") || !!e.target.closest("#emojiPop");
    if (!onUi){
      if (editingId){
        const editor = nodesLayer.querySelector(`.node[data-id="${CSS.escape(editingId)}"] .text`);
        if (editor) editor.blur();
      }
      // –∫–ª–∏–∫ –≤ –ø—É—Å—Ç–æ—Ç—É ‚Äî –ø—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º –º–µ–Ω—é
      ctxOpen = false; emojiOpen = false;
      positionDotsAndMenus();

      drag = {
        kind:"pan",
        pointerId:e.pointerId,
        sx:e.clientX, sy:e.clientY,
        moved:false,
        startViewX: map.view.x,
        startViewY: map.view.y
      };
      scene.setPointerCapture(e.pointerId);
    }
  });

  scene.addEventListener("pointermove", (e) => {
    if (!drag || drag.pointerId !== e.pointerId) return;
    if (drag.kind !== "pan") return;

    const dx = e.clientX - drag.sx;
    const dy = e.clientY - drag.sy;
    const dist = Math.hypot(dx, dy);
    if (!drag.moved && dist > DRAG_THRESHOLD) drag.moved = true;
    if (!drag.moved) return;

    map.view.x = drag.startViewX + dx;
    map.view.y = drag.startViewY + dy;
    applyTransform();
    autosave();
  });

  scene.addEventListener("pointerup", (e) => {
    if (drag && drag.kind === "pan" && drag.pointerId === e.pointerId) drag = null;
  });
  scene.addEventListener("pointercancel", (e) => {
    if (drag && drag.pointerId === e.pointerId) drag = null;
  });

  // Wheel zoom: –¥–µ–ª–∞–µ–º —Å—Ç—É–ø–µ–Ω—å–∫–∏ –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –º—ã–ª–∞
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();

    const delta = Math.sign(e.deltaY);
    const step = 0.05;
    let nk = map.view.k + (delta > 0 ? -step : step);
    nk = Math.max(0.25, Math.min(3.2, nk));
    nk = Math.round(nk / step) * step;

    const before = clientToWorld(e.clientX, e.clientY);

    const r = scene.getBoundingClientRect();
    const vx = e.clientX - r.left;
    const vy = e.clientY - r.top;

    map.view.k = nk;
    map.view.x = vx - before.x * nk;
    map.view.y = vy - before.y * nk;

    applyTransform();
    positionDotsAndMenus();
    autosave();
  }, {passive:false});

  // dblclick empty -> create node
  scene.addEventListener("dblclick", (e) => {
    if (e.target.closest(".node") || e.target.closest(".collapseDot") || e.target.closest("#ctx") || e.target.closest("#dotsBtn") || e.target.closest("#emojiPop")) return;
    const p = clientToWorld(e.clientX, e.clientY);
    const id = addNodeAt(p.x - 90, p.y - 30, "–ù–æ–≤–∞—è –∏–¥–µ—è", PALETTE[0]);
    beginEdit(id, true);
  });

  // keyboard helpers
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape"){
      if (emojiOpen){ emojiOpen = false; positionDotsAndMenus(); return; }
      if (ctxOpen){ ctxOpen = false; positionDotsAndMenus(); return; }
    }
    if (e.key === "Tab" && selectedId && !editingId){
      e.preventDefault();
      const id = addChildFrom(selectedId);
      if (id) beginEdit(id, true);
    }
    if (e.key === "Enter" && selectedId && !editingId){
      e.preventDefault();
      const id = addSiblingFrom(selectedId);
      if (id) beginEdit(id, true);
    }
    if ((e.key === "Delete" || e.key === "Backspace") && selectedId && !editingId){
      e.preventDefault();
      deleteSubtree(selectedId);
    }
  });

  // ---- Download dropdown ----
  function closeDownload(){
    downloadDrop.style.display = "none";
  }
  downloadBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    downloadDrop.style.display = (downloadDrop.style.display === "block") ? "none" : "block";
  });
  document.addEventListener("pointerdown", (e) => {
    if (e.target.closest(".menuWrap")) return;
    closeDownload();
  });

  exportOneBtn.onclick = () => {
    if (!active) return;
    commitMap();
    const payload = { kind:"mindmap_project", version:7, project: store.projects[store.activeId] };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    const safe = (active.name || "mindmap").replace(/[^\w\d\-_.]+/g,"_");
    a.download = safe + ".json";
    a.click();
    URL.revokeObjectURL(a.href);
    closeDownload();
    showToast("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  };

  exportAllBtn.onclick = () => {
    commitMap();
    const payload = { kind:"mindmap_store", version:7, store };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "mindmaps_all.json";
    a.click();
    URL.revokeObjectURL(a.href);
    closeDownload();
    showToast("–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –≥–æ—Ç–æ–≤");
  };

  importOne.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_project" || !obj.project) throw new Error("bad");
        const p = obj.project;
        if (!p.id) p.id = uid();
        p.data = normalizeMapData(p.data || {});
        p.createdAt ||= nowTs();
        p.updatedAt ||= nowTs();
        store.projects[p.id] = p;
        store.activeId = p.id;
        saveStore();
        rebuildProjectSelect();
        setActiveProject(p.id);
        showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
      }catch(err){
        showToast("–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
    closeDownload();
  });

  importAll.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_store" || !obj.store) throw new Error("bad");
        const s = obj.store;
        if (!s.projects || typeof s.projects !== "object") throw new Error("bad");
        Object.values(s.projects).forEach(p => {
          if (!p.id) p.id = uid();
          p.name ||= "–ú–∞–π–Ω–¥–º—ç–ø";
          p.createdAt ||= nowTs();
          p.updatedAt ||= nowTs();
          p.data = normalizeMapData(p.data || {});
        });
        store = s;
        if (!store.activeId || !store.projects[store.activeId]){
          store.activeId = Object.keys(store.projects)[0];
        }
        saveStore();
        rebuildProjectSelect();
        setActiveProject(store.activeId);
        showToast("–ò–º–ø–æ—Ä—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω");
      }catch(err){
        showToast("–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
    closeDownload();
  });

  // ---- Topbar project controls ----
  projectSelect.addEventListener("change", () => setActiveProject(projectSelect.value));

  document.getElementById("projNew").onclick = () => {
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–∞–π–Ω–¥–º—ç–ø–∞:", "–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    const p = createEmptyProject((name || "–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø").trim());
    rebuildProjectSelect();
    setActiveProject(p.id);
    showToast("–°–æ–∑–¥–∞–Ω–æ");
  };

  // ---- INIT ----
  function init(){
    store = loadStore();
    if (!store){
      store = { activeId:null, projects:{} };
      createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    } else {
      if (!store.projects || Object.keys(store.projects).length === 0){
        store.projects = {};
        createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
      }
      if (!store.activeId || !store.projects[store.activeId]){
        store.activeId = Object.keys(store.projects)[0];
      }
    }
    saveStore();
    rebuildProjectSelect();
    setActiveProject(store.activeId);
  }

  init();
})();
</script>
</body>
</html>
