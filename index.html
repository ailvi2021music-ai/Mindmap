<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini MindMap (v4)</title>
  <meta name="theme-color" content="#f3f7ff" />
  <style>
    :root{
      --text:#0b1324;
      --muted:rgba(11,19,36,.60);
      --panel:rgba(255,255,255,.75);
      --stroke:rgba(11,19,36,.12);
      --shadow: 0 18px 60px rgba(10,20,40,.18);
      --grid:rgba(10,20,40,.06);
      --nodeRadius:16px;
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1000px 700px at 20% 10%, rgba(89,195,255,.28), transparent 58%),
        radial-gradient(900px 650px at 85% 20%, rgba(255,92,122,.20), transparent 60%),
        radial-gradient(1000px 700px at 55% 95%, rgba(60,224,122,.22), transparent 60%),
        linear-gradient(180deg, #f7fbff, #eef4ff 55%, #f8fbff);
    }

    .app{ height:100%; display:flex; flex-direction:column; }

    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:20;
      background: rgba(255,255,255,.68);
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; margin-right:8px; }
    .brand b{ font-size:14px; letter-spacing:.2px; }
    .brand span{ color:var(--muted); font-size:12px; }

    .btn{
      appearance:none; border:1px solid var(--stroke); background:rgba(255,255,255,.65);
      color:var(--text); padding:9px 10px; border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.06);
      cursor:pointer; user-select:none;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{ border-color: rgba(89,195,255,.45); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.55); }
    .btn.danger{ border-color: rgba(255,92,122,.55); }
    .sep{ width:1px; height:26px; background:var(--stroke); margin:0 2px; }

    .stageWrap{ flex:1; position:relative; overflow:hidden; }
    .stageWrap::before{
      content:""; position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 42px 42px, 7px 7px;
      opacity:.75;
      pointer-events:none;
    }

    /* iOS/Safari fix */
    svg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none; /* –º—ã —Å–∞–º–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º pan/zoom */
      z-index:1;
    }

    .link{
      stroke: rgba(30,90,150,.40);
      stroke-width: 2.2;
      fill: none;
    }
    .link.selected{ stroke: rgba(255,92,122,.70); }

    .node{
      filter: drop-shadow(0 16px 26px rgba(10,20,40,.16));
      cursor: grab;
    }
    .node.selected rect{
      stroke: rgba(89,195,255,.95) !important;
      stroke-width: 2.4 !important;
    }
    .node rect{
      rx: var(--nodeRadius);
      ry: var(--nodeRadius);
    }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(255,255,255,.72);
      border:1px solid rgba(11,19,36,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(11,19,36,.86);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(720px, calc(100% - 24px));
      z-index:30;
    }
    .toast.show{ opacity:1; }

    input[type="file"]{ display:none; }

    @media (max-width: 560px){
      .brand span{ display:none; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <b>Mini MindMap</b>
      <span>–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –ø–æ —É–∑–ª—É ‚Äî –¥–æ—á–µ—Ä–Ω–∏–π. –¢—Ä–æ–π–Ω–æ–π –∫–ª–∏–∫ –ø–æ —É–∑–ª—É ‚Äî —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞.</span>
    </div>

    <button class="btn primary" id="addRoot">+ –¶–µ–Ω—Ç—Ä</button>
    <button class="btn" id="addChild">+ –î–æ—á–µ—Ä–Ω–∏–π</button>
    <button class="btn" id="autoLayout">–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞</button>

    <div class="sep"></div>

    <button class="btn danger" id="del">–£–¥–∞–ª–∏—Ç—å</button>

    <div class="sep"></div>

    <button class="btn" id="export">–≠–∫—Å–ø–æ—Ä—Ç</button>
    <label class="btn" for="importFile">–ò–º–ø–æ—Ä—Ç</label>
    <input id="importFile" type="file" accept="application/json" />

    <div class="sep"></div>

    <button class="btn" id="resetView">–°–±—Ä–æ—Å –≤–∏–¥–∞</button>
    <button class="btn danger" id="clearAll">–û—á–∏—Å—Ç–∏—Ç—å</button>
  </header>

  <div class="stageWrap" id="wrap">
    <svg id="svg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  const STORAGE_KEY = "mini_mindmap_v4";
  const MIGRATE_KEYS = ["mini_mindmap_v3", "mini_mindmap_v2", "mini_mindmap_v1"];

  const svg = document.getElementById("svg");
  const wrap = document.getElementById("wrap");
  const toast = document.getElementById("toast");

  const PALETTE = [
    {name:"Sky",    fill:"rgba(89,195,255,.20)", stroke:"rgba(33,140,210,.60)"},
    {name:"Rose",   fill:"rgba(255,92,122,.18)", stroke:"rgba(230,70,95,.62)"},
    {name:"Lime",   fill:"rgba(60,224,122,.18)", stroke:"rgba(30,170,85,.60)"},
    {name:"Amber",  fill:"rgba(255,209,102,.20)", stroke:"rgba(205,150,40,.62)"},
    {name:"Violet", fill:"rgba(176,122,255,.18)", stroke:"rgba(135,90,210,.62)"},
    {name:"Slate",  fill:"rgba(255,255,255,.80)", stroke:"rgba(11,19,36,.18)"}
  ];

  let state = {
    nodes: [],   // {id,x,y,w,h,text,icon,style:{fill,stroke}, childColorNext}
    links: [],   // {id,a,b}
    view: {x:24,y:24,k:1}
  };

  let selectedNodeId = null;
  let selectedLinkId = null;

  // pointer interactions
  let drag = null; // {type:'node'|'pan', sx,sy, base:[{id,x,y}] or ox,oy}
  const pointers = new Map(); // pointerId -> {x,y}
  let pinch = null; // {dist0, k0, mid0:{x,y}, view0:{x,y}}

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  // click counting per node for double/triple
  const clickState = new Map(); // nodeId -> {count, t}
  const CLICK_WINDOW_MS = 420;

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 1400);
  }

  function getNode(id){ return state.nodes.find(n => n.id === id); }
  function getLink(id){ return state.links.find(l => l.id === id); }

  function clientToWorld(cx, cy){
    const r = svg.getBoundingClientRect();
    return {
      x: (cx - r.left - state.view.x) / state.view.k,
      y: (cy - r.top  - state.view.y) / state.view.k
    };
  }

  function setView(x, y, k){
    state.view.x = x;
    state.view.y = y;
    state.view.k = Math.max(0.25, Math.min(3.2, k));
    render(); save();
  }
  function fitDefault(){ setView(24,24,1); }

  function measureNode(text){
    const baseW = 190;
    const maxW  = 340;
    const approx = Math.min(maxW, Math.max(baseW, (text||"").length * 7.0 + 70));
    return {w: approx, h: 58};
  }

  function addNode(x, y, text="–ù–æ–≤–∞—è –∏–¥–µ—è", icon="üí°", style=PALETTE[0]){
    const {w,h} = measureNode(text);
    const id = uid();
    state.nodes.push({
      id, x, y, w, h,
      text,
      icon: (icon||"").trim(),
      style: {fill: style.fill, stroke: style.stroke},
      childColorNext: 0
    });
    selectedNodeId = id;
    selectedLinkId = null;
    save(); render();
    return id;
  }

  function addLink(a, b){
    if (!a || !b || a===b) return;
    const exists = state.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    state.links.push({id: uid(), a, b});
    save(); render();
  }

  // –≤—ã—Ö–æ–¥ –ª–∏–Ω–∏–∏ —Å –∫—Ä–∞—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
  function edgePoint(fromNode, toNode){
    const cx = fromNode.x + fromNode.w/2;
    const cy = fromNode.y + fromNode.h/2;
    const tx = toNode.x + toNode.w/2;
    const ty = toNode.y + toNode.h/2;
    let dx = tx - cx, dy = ty - cy;
    if (dx === 0 && dy === 0) { dx = 1; dy = 0; }

    const hw = fromNode.w/2, hh = fromNode.h/2;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const sx = adx ? (hw / adx) : Infinity;
    const sy = ady ? (hh / ady) : Infinity;
    const t = Math.min(sx, sy);
    return { x: cx + dx * t, y: cy + dy * t };
  }

  // inline rename inside the node
  function beginInlineEdit(nodeId, textDiv){
    const n = getNode(nodeId);
    if (!n || !textDiv) return;

    // already editing?
    if (textDiv.isContentEditable) return;

    textDiv.contentEditable = "true";
    textDiv.style.outline = "none";
    textDiv.style.cursor = "text";
    textDiv.style.userSelect = "text";
    textDiv.focus();

    // put caret at end
    const range = document.createRange();
    range.selectNodeContents(textDiv);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    const finish = (saveChanges) => {
      textDiv.contentEditable = "false";
      textDiv.style.cursor = "";
      textDiv.style.userSelect = "none";

      if (saveChanges){
        const val = (textDiv.textContent || "").trim();
        n.text = val || "–ò–¥–µ—è";
        const {w,h} = measureNode(n.text);
        n.w = w; n.h = h;
        save(); render();
      } else {
        textDiv.textContent = n.text || "–ò–¥–µ—è";
      }
    };

    const onKey = (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        textDiv.blur();
      }
      if (e.key === "Escape"){
        e.preventDefault();
        finish(false);
        textDiv.blur();
      }
    };

    const onBlur = () => {
      textDiv.removeEventListener("keydown", onKey);
      textDiv.removeEventListener("blur", onBlur);
      finish(true);
    };

    textDiv.addEventListener("keydown", onKey);
    textDiv.addEventListener("blur", onBlur);
  }

  function addChildFrom(parentId){
    const parent = getNode(parentId);
    if (!parent) return null;

    // –∫–∞–∂–¥—ã–π –Ω–æ–≤—ã–π —Ä–µ–±—ë–Ω–æ–∫ ‚Äî —Å–ª–µ–¥—É—é—â–∏–π —Ü–≤–µ—Ç –ø–æ –ø–∞–ª–∏—Ç—Ä–µ
    const idx = ((parent.childColorNext || 0) + 1) % PALETTE.length;
    parent.childColorNext = (parent.childColorNext || 0) + 1;

    const style = PALETTE[idx];
    const x = parent.x + parent.w + 140;
    const y = parent.y + (Math.random()*70 - 35);

    const childId = addNode(x, y, "–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è", "‚úÖ", style);
    addLink(parentId, childId);
    return childId;
  }

  // -------- SVG helpers
  function el(name, attrs={}){
    const x = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) x.setAttribute(k, String(v));
    return x;
  }

  // -------- render
  function render(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const gView = el("g", { transform: `translate(${state.view.x},${state.view.y}) scale(${state.view.k})` });
    svg.appendChild(gView);

    // links
    state.links.forEach(l => {
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) return;

      const p1 = edgePoint(a, b);
      const p2 = edgePoint(b, a);

      const dx = p2.x - p1.x;
      const c1x = p1.x + dx * 0.33;
      const c2x = p1.x + dx * 0.66;

      const d = `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`;
      const path = el("path", {
        d,
        class: "link" + (l.id === selectedLinkId ? " selected" : ""),
        "data-link-id": l.id
      });
      path.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        selectedLinkId = l.id;
        selectedNodeId = null;
        render();
      });
      gView.appendChild(path);
    });

    // nodes
    state.nodes.forEach(n => {
      const isSel = (n.id === selectedNodeId);

      const gn = el("g", {
        class: "node" + (isSel ? " selected" : ""),
        transform: `translate(${n.x},${n.y})`,
        "data-node-id": n.id
      });

      const rect = el("rect", {
        width: n.w, height: n.h,
        style: `fill:${n.style?.fill || "rgba(255,255,255,.8)"};stroke:${n.style?.stroke || "rgba(11,19,36,.18)"};stroke-width:1.2;`
      });
      gn.appendChild(rect);

      // HTML inside node (fixed emoji clipping)
      const fo = el("foreignObject", { x: 0, y: 0, width: n.w, height: n.h });
      const div = document.createElement("div");
      div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
      div.style.cssText = `
        width:${n.w}px; height:${n.h}px;
        display:flex; align-items:center; gap:10px;
        padding: 10px 12px;
        color: rgba(11,19,36,.95);
        font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        overflow:hidden;
        user-select:none;
      `;

      const icon = document.createElement("div");
      icon.style.cssText = `
        flex:0 0 auto;
        font-size:18px;
        line-height: 1;
        height: 20px;
        display:flex;
        align-items:center;
        justify-content:center;
        overflow: visible;
      `;
      icon.textContent = n.icon || "";

      const text = document.createElement("div");
      text.style.cssText = `
        flex:1 1 auto;
        overflow:hidden;
        display:-webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        word-break: break-word;
        line-height: 1.15;
        padding-bottom: 2px;
        cursor: default;
      `;
      text.textContent = n.text || "";

      div.appendChild(icon);
      div.appendChild(text);
      fo.appendChild(div);
      gn.appendChild(fo);

      // selection + drag
      gn.addEventListener("pointerdown", (e) => {
        e.stopPropagation();

        // select
        selectedNodeId = n.id;
        selectedLinkId = null;
        render();

        // drag node
        drag = {
          type: "node",
          sx: e.clientX, sy: e.clientY,
          base: [{id:n.id, x:n.x, y:n.y}]
        };
        svg.setPointerCapture(e.pointerId);
      });

      // Custom click counter: double -> add child, triple -> inline rename
      gn.addEventListener("pointerup", (e) => {
        e.stopPropagation();
        const now = Date.now();
        const prev = clickState.get(n.id) || {count:0, t:0};
        const within = (now - prev.t) <= CLICK_WINDOW_MS;

        const nextCount = within ? (prev.count + 1) : 1;
        clickState.set(n.id, {count: nextCount, t: now});

        clearTimeout(prev._timer);
        const timer = setTimeout(() => {
          const st = clickState.get(n.id);
          if (!st) return;

          if (st.count === 2){
            const childId = addChildFrom(n.id);
            // —á—É—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∏—Ç—å
            selectedNodeId = childId;
            selectedLinkId = null;
            render();
          }
          if (st.count >= 3){
            // inline edit in place
            beginInlineEdit(n.id, text);
          }

          clickState.delete(n.id);
        }, CLICK_WINDOW_MS + 40);

        // store timer
        const cur = clickState.get(n.id);
        if (cur) cur._timer = timer;
      });

      gView.appendChild(gn);
    });
  }

  // -------- background pan (drag empty space)
  svg.addEventListener("pointerdown", (e) => {
    // if clicked on empty, start panning
    const nodeId = findNodeFromEvent(e);
    const linkId = findLinkFromEvent(e);
    if (!nodeId && !linkId){
      selectedNodeId = null;
      selectedLinkId = null;
      render();

      drag = { type:"pan", sx:e.clientX, sy:e.clientY, ox:state.view.x, oy:state.view.y };
      svg.setPointerCapture(e.pointerId);
    }

    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (pointers.size === 2){
      // start pinch
      const pts = [...pointers.values()];
      const dx = pts[1].x - pts[0].x;
      const dy = pts[1].y - pts[0].y;
      const dist = Math.hypot(dx, dy);
      const mid = {x: (pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
      pinch = { dist0: dist, k0: state.view.k, mid0: mid, view0:{x:state.view.x, y:state.view.y} };
    }
  });

  svg.addEventListener("pointermove", (e) => {
    if (pointers.has(e.pointerId)){
      pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    }

    // pinch zoom
    if (pointers.size === 2 && pinch){
      const pts = [...pointers.values()];
      const dx = pts[1].x - pts[0].x;
      const dy = pts[1].y - pts[0].y;
      const dist = Math.hypot(dx, dy);
      const scale = dist / Math.max(1, pinch.dist0);
      const nk = Math.max(0.25, Math.min(3.2, pinch.k0 * scale));

      // zoom around midpoint
      const mid = {x: (pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
      const before = clientToWorld(mid.x, mid.y);

      state.view.k = nk;
      const r = svg.getBoundingClientRect();
      const vx = mid.x - r.left;
      const vy = mid.y - r.top;
      state.view.x = vx - before.x * nk;
      state.view.y = vy - before.y * nk;

      render();
      return;
    }

    if (!drag) return;

    if (drag.type === "node"){
      const dx = (e.clientX - drag.sx) / state.view.k;
      const dy = (e.clientY - drag.sy) / state.view.k;
      const b = drag.base[0];
      const n = getNode(b.id);
      if (n){
        n.x = b.x + dx;
        n.y = b.y + dy;
        render();
      }
      return;
    }

    if (drag.type === "pan"){
      const dx = (e.clientX - drag.sx);
      const dy = (e.clientY - drag.sy);
      state.view.x = drag.ox + dx;
      state.view.y = drag.oy + dy;
      render();
      return;
    }
  });

  svg.addEventListener("pointerup", (e) => {
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinch = null;

    if (drag){
      drag = null;
      save();
      render();
    }
  });
  svg.addEventListener("pointercancel", (e) => {
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinch = null;
    drag = null;
  });

  // wheel zoom (desktop)
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;

    const before = clientToWorld(e.clientX, e.clientY);
    const nk = Math.max(0.25, Math.min(3.2, state.view.k * factor));

    const r = svg.getBoundingClientRect();
    const vx = e.clientX - r.left;
    const vy = e.clientY - r.top;

    state.view.k = nk;
    state.view.x = vx - before.x * nk;
    state.view.y = vy - before.y * nk;

    render(); save();
  }, {passive:false});

  // dblclick empty => new node
  svg.addEventListener("dblclick", (e) => {
    // –µ—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –ø–æ —É–∑–ª—É ‚Äî –æ–Ω —Å–∞–º –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —á–µ—Ä–µ–∑ —Å—á—ë—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤
    const nodeId = findNodeFromEvent(e);
    if (nodeId) return;
    const p = clientToWorld(e.clientX, e.clientY);
    addNode(p.x - 95, p.y - 29, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
  });

  function findNodeFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-node-id");
      if (id) return id;
    }
    return null;
  }
  function findLinkFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-link-id");
      if (id) return id;
    }
    return null;
  }

  // -------- delete / export / import / layout
  function save(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){}
  }

  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw){
        const obj = JSON.parse(raw);
        if (obj && Array.isArray(obj.nodes) && Array.isArray(obj.links)){
          state = obj;
          state.view ||= {x:24,y:24,k:1};
          // normalize
          state.nodes.forEach(n => {
            n.text ||= "–ò–¥–µ—è";
            const {w,h} = measureNode(n.text);
            n.w ||= w; n.h ||= h;
            n.icon = (typeof n.icon === "string") ? n.icon : "üí°";
            if (!n.style) n.style = {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke};
            n.childColorNext = n.childColorNext || 0;
          });
          return true;
        }
      }

      // migrate
      for (const k of MIGRATE_KEYS){
        const oldRaw = localStorage.getItem(k);
        if (!oldRaw) continue;
        const old = JSON.parse(oldRaw);
        if (!old || !Array.isArray(old.nodes) || !Array.isArray(old.links)) continue;

        state.nodes = old.nodes.map(n => {
          const text = n.text || "–ò–¥–µ—è";
          const {w,h} = measureNode(text);
          return {
            id: n.id || uid(),
            x: Number(n.x)||0,
            y: Number(n.y)||0,
            w: n.w || w,
            h: n.h || h,
            text,
            icon: (typeof n.icon === "string") ? n.icon : "üí°",
            style: n.style ? n.style : {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
            childColorNext: n.childColorNext || 0
          };
        });
        state.links = old.links.map(l => ({id: l.id || uid(), a:l.a, b:l.b})).filter(l => l.a && l.b);
        state.view = old.view || {x:24,y:24,k:1};
        save();
        return true;
      }

      return false;
    }catch(e){
      return false;
    }
  }

  function deleteSelected(){
    if (selectedNodeId){
      const id = selectedNodeId;
      state.links = state.links.filter(l => l.a !== id && l.b !== id);
      state.nodes = state.nodes.filter(n => n.id !== id);
      selectedNodeId = null;
      save(); render();
      showToast("–£–∑–µ–ª —É–¥–∞–ª—ë–Ω");
      return;
    }
    if (selectedLinkId){
      state.links = state.links.filter(l => l.id !== selectedLinkId);
      selectedLinkId = null;
      save(); render();
      showToast("–°–≤—è–∑—å —É–¥–∞–ª–µ–Ω–∞");
      return;
    }
    showToast("–ù–µ—á–µ–≥–æ —É–¥–∞–ª—è—Ç—å");
  }

  function exportJSON(){
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "mindmap.json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  }

  function importJSON(file){
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.links)) throw new Error("bad");
        obj.view ||= {x:24,y:24,k:1};
        obj.nodes.forEach(n => {
          n.text ||= "–ò–¥–µ—è";
          const {w,h} = measureNode(n.text);
          n.w ||= w; n.h ||= h;
          n.icon = (typeof n.icon === "string") ? n.icon : "üí°";
          if (!n.style) n.style = {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke};
          n.childColorNext = n.childColorNext || 0;
        });
        state = obj;
        selectedNodeId = null;
        selectedLinkId = null;
        save(); render();
        showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
      }catch(e){
        showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å JSON");
      }
    };
    fr.readAsText(file);
  }

  function autoLayout(){
    const rootId = selectedNodeId || (state.nodes[0] && state.nodes[0].id);
    if (!rootId){ showToast("–ù–µ—Ç —É–∑–ª–æ–≤"); return; }

    const adj = new Map();
    for (const n of state.nodes) adj.set(n.id, []);
    for (const l of state.links){
      if (!adj.has(l.a) || !adj.has(l.b)) continue;
      adj.get(l.a).push(l.b);
      adj.get(l.b).push(l.a);
    }

    const children = new Map();
    for (const n of state.nodes) children.set(n.id, []);
    const seen = new Set([rootId]);
    const q = [rootId];

    while(q.length){
      const v = q.shift();
      for (const u of (adj.get(v)||[])){
        if (seen.has(u)) continue;
        seen.add(u);
        children.get(v).push(u);
        q.push(u);
      }
    }

    const r = svg.getBoundingClientRect();
    const center = clientToWorld(r.left + r.width/2, r.top + r.height/2);
    const ring = 240;

    function place(v, depth, a0, a1){
      const n = getNode(v);
      if (!n) return;
      const ang = (a0+a1)/2;
      const rad = depth * ring;

      if (depth === 0){
        n.x = center.x - n.w/2;
        n.y = center.y - n.h/2;
      } else {
        n.x = center.x + Math.cos(ang)*rad - n.w/2;
        n.y = center.y + Math.sin(ang)*rad - n.h/2;
      }

      const kids = children.get(v) || [];
      if (!kids.length) return;
      const step = (a1-a0)/kids.length;
      kids.forEach((c,i)=> place(c, depth+1, a0+step*i, a0+step*(i+1)));
    }

    place(rootId, 0, -Math.PI+0.2, Math.PI-0.2);
    save(); render();
    showToast("–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –≥–æ—Ç–æ–≤–∞");
  }

  // -------- buttons
  document.getElementById("addRoot").addEventListener("click", () => {
    if (state.nodes.length === 0){
      addNode(260, 180, "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è", "üéØ", PALETTE[0]);
      showToast("–°–æ–∑–¥–∞–Ω —Ü–µ–Ω—Ç—Ä");
    } else {
      const r = svg.getBoundingClientRect();
      const p = clientToWorld(r.left + r.width/2, r.top + r.height/2);
      addNode(p.x - 95, p.y - 29, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
    }
  });

  document.getElementById("addChild").addEventListener("click", () => {
    if (!selectedNodeId){ showToast("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —É–∑–µ–ª"); return; }
    addChildFrom(selectedNodeId);
  });

  document.getElementById("autoLayout").addEventListener("click", autoLayout);
  document.getElementById("del").addEventListener("click", deleteSelected);
  document.getElementById("export").addEventListener("click", exportJSON);

  document.getElementById("importFile").addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) importJSON(f);
    e.target.value = "";
  });

  document.getElementById("resetView").addEventListener("click", () => {
    fitDefault();
    showToast("–í–∏–¥ —Å–±—Ä–æ—à–µ–Ω");
  });

  document.getElementById("clearAll").addEventListener("click", () => {
    if (!confirm("–£–¥–∞–ª–∏—Ç—å –≤—Å—ë?")) return;
    state.nodes = [];
    state.links = [];
    selectedNodeId = null;
    selectedLinkId = null;
    fitDefault();
    save(); render();
    showToast("–û—á–∏—â–µ–Ω–æ");
  });

  // init
  const ok = load();
  if (!ok){
    fitDefault();
    addNode(260, 180, "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è", "üéØ", PALETTE[0]);
  }
  render();

})();
</script>
</body>
</html>
