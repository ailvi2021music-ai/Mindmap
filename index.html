<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini MindMap (v2)</title>
  <meta name="theme-color" content="#0b1324" />
  <style>
    :root{
      --bg0:#070b16;
      --bg1:#0b1324;
      --panel:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.12);
      --text:#eaf2ff;
      --muted:rgba(234,242,255,.65);
      --accent:#59c3ff;
      --danger:#ff5c7a;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius:16px;
      --nodeRadius:14px;
      --grid:rgba(255,255,255,.05);
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(89,195,255,.18), transparent 55%),
        radial-gradient(900px 700px at 90% 20%, rgba(255,92,122,.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .app{ height:100%; display:flex; flex-direction:column; }
    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:10;
      background: linear-gradient(180deg, rgba(11,19,36,.92), rgba(11,19,36,.65));
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; margin-right:8px; }
    .brand b{ font-size:14px; letter-spacing:.2px; }
    .brand span{ color:var(--muted); font-size:12px; }

    .btn{
      appearance:none; border:1px solid var(--stroke); background:var(--panel);
      color:var(--text); padding:9px 10px; border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.25);
      cursor:pointer; user-select:none;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{ border-color: rgba(89,195,255,.38); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.45); }
    .btn.danger{ border-color: rgba(255,92,122,.45); }
    .sep{ width:1px; height:26px; background:var(--stroke); margin:0 2px; }

    .hint{
      margin-left:auto; color:var(--muted); font-size:12px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .hint code{
      background:rgba(255,255,255,.06);
      border:1px solid var(--stroke);
      padding:2px 6px;
      border-radius:8px;
      color:var(--text);
    }

    .stageWrap{ flex:1; position:relative; overflow:hidden; }
    .stageWrap::before{
      content:""; position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 36px 36px, 6px 6px;
      opacity:.35;
      pointer-events:none;
      transform: translateZ(0);
    }

    /* ‚úÖ iOS/Safari FIX: –±–µ–∑ width/height SVG –æ—Å—Ç–∞—ë—Ç—Å—è 300√ó150 */
    svg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
    }

    .link{
      stroke: rgba(89,195,255,.55);
      stroke-width: 2.2;
      fill: none;
    }
    .link.selected{ stroke: rgba(255,92,122,.75); }

    .group rect{
      fill: rgba(255,255,255,.04);
      stroke: rgba(255,255,255,.12);
      stroke-width: 1.2;
      rx: 18; ry: 18;
    }
    .group.selected rect{
      stroke: rgba(89,195,255,.75);
      stroke-width: 2.2;
    }
    .groupLabel{ font-size: 12px; fill: rgba(234,242,255,.90); }
    .groupBadge{
      fill: rgba(0,0,0,.25);
      stroke: rgba(255,255,255,.12);
      stroke-width: 1;
      rx: 10; ry: 10;
    }

    .node{
      cursor:grab;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.45));
    }
    .node rect{
      fill: rgba(255,255,255,.07);
      stroke: rgba(255,255,255,.18);
      stroke-width:1.2;
      rx: var(--nodeRadius);
      ry: var(--nodeRadius);
    }
    .node.selected rect{
      stroke: rgba(89,195,255,.95);
      stroke-width: 2.2;
    }
    .node.multi rect{
      stroke: rgba(255,209,102,.9);
      stroke-width: 2.2;
    }
    .node text{
      fill: var(--text);
      font-size: 14px;
      dominant-baseline: middle;
      pointer-events:none;
    }
    .node .sub{
      fill: rgba(234,242,255,.72);
      font-size: 11.5px;
    }
    .icon{ font-size: 16px; opacity:.95; }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(234,242,255,.92);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(700px, calc(100% - 24px));
      z-index: 5;
    }
    .toast.show{ opacity:1; }

    input[type="file"]{ display:none; }

    @media (max-width: 560px){
      .hint{ display:none; }
      .brand{ width:100%; }
      .brand span{ display:none; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <b>Mini MindMap</b>
      <span>v2: –∞–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞, —Ü–≤–µ—Ç–∞/–∏–∫–æ–Ω–∫–∏, –≥—Ä—É–ø–ø—ã ‚Ä¢ Shift+–∫–ª–∏–∫ ‚Äî —Å–≤—è–∑—å ‚Ä¢ Ctrl/‚åò+–∫–ª–∏–∫ ‚Äî –º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä</span>
    </div>

    <button class="btn primary" id="addRoot">+ –¶–µ–Ω—Ç—Ä</button>
    <button class="btn" id="addChild">+ –î–æ—á–µ—Ä–Ω–∏–π</button>
    <button class="btn" id="autoLayout">–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞</button>

    <div class="sep"></div>

    <button class="btn" id="edit">–ü—Ä–∞–≤–∫–∞</button>
    <button class="btn" id="setStyle">–°—Ç–∏–ª—å</button>
    <button class="btn" id="makeGroup">–ì—Ä—É–ø–ø–∞</button>
    <button class="btn danger" id="del">–£–¥–∞–ª–∏—Ç—å</button>

    <div class="sep"></div>

    <button class="btn" id="export">–≠–∫—Å–ø–æ—Ä—Ç</button>
    <label class="btn" for="importFile">–ò–º–ø–æ—Ä—Ç</label>
    <input id="importFile" type="file" accept="application/json" />

    <div class="sep"></div>

    <button class="btn" id="resetView">–°–±—Ä–æ—Å –≤–∏–¥–∞</button>
    <button class="btn danger" id="clearAll">–û—á–∏—Å—Ç–∏—Ç—å</button>

    <div class="hint">
      <span><code>Drag</code> –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å</span>
      <span><code>Space+Drag</code> –ø–∞–Ω</span>
      <span><code>Wheel</code> –∑—É–º</span>
      <span><code>Enter</code> —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å</span>
    </div>
  </header>

  <div class="stageWrap" id="wrap">
    <svg id="svg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  const STORAGE_KEY = "mini_mindmap_v2";
  const OLD_KEY = "mini_mindmap_v1";
  const svg = document.getElementById("svg");
  const wrap = document.getElementById("wrap");
  const toast = document.getElementById("toast");

  const PALETTE = [
    {name:"Sky",    fill:"rgba(89,195,255,.12)", stroke:"rgba(89,195,255,.65)"},
    {name:"Rose",   fill:"rgba(255,92,122,.11)", stroke:"rgba(255,92,122,.65)"},
    {name:"Lime",   fill:"rgba(60,224,122,.10)", stroke:"rgba(60,224,122,.65)"},
    {name:"Amber",  fill:"rgba(255,209,102,.10)", stroke:"rgba(255,209,102,.70)"},
    {name:"Violet", fill:"rgba(176,122,255,.10)", stroke:"rgba(176,122,255,.70)"},
    {name:"Slate",  fill:"rgba(255,255,255,.06)", stroke:"rgba(255,255,255,.22)"}
  ];

  let state = {
    nodes: [],   // {id,x,y,text,note,w,h,icon,style:{fill,stroke},groupId}
    links: [],   // {id,a,b}
    groups: [],  // {id,name,style:{fill,stroke},pad}
    view: { x: 0, y: 0, k: 1 }
  };

  let selectedNodeId = null;
  let selectedLinkId = null;
  let selectedGroupId = null;
  let multi = new Set();

  let drag = null;       // {type:'node'|'pan'|'group', ...}
  let linkDraft = null;  // {fromId,x,y}

  let isSpaceDown = false;
  let pressTimer = null;

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 1400);
  }

  // ---------- coords ----------
  function clientToWorld(cx, cy){
    const r = svg.getBoundingClientRect();
    return {
      x: (cx - r.left - state.view.x) / state.view.k,
      y: (cy - r.top  - state.view.y) / state.view.k
    };
  }

  function setView(x, y, k){
    state.view.x = x;
    state.view.y = y;
    state.view.k = Math.max(0.25, Math.min(2.8, k));
    render(); save();
  }

  function fitDefault(){
    setView(20, 20, 1);
  }

  // ---------- data helpers ----------
  function measureNode(text, note){
    const base = 96;
    const extra = Math.min(340, (text || "").length * 7.2);
    const w = Math.max(base, extra) + 30;
    const h = note ? 60 : 46;
    return {w, h};
  }
  function defaultStyle(){ return PALETTE[0]; }

  function getNode(id){ return state.nodes.find(n => n.id === id); }
  function getLink(id){ return state.links.find(l => l.id === id); }
  function getGroup(id){ return state.groups.find(g => g.id === id); }

  function addNode(x, y, text="–ò–¥–µ—è", note="", icon="üí°", style=defaultStyle()){
    const {w,h} = measureNode(text, note);
    const id = uid();
    state.nodes.push({
      id, x, y, text, note, w, h,
      icon: (icon || "").trim(),
      style: style ? {fill: style.fill, stroke: style.stroke} : {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
      groupId: null
    });
    selectNode(id);
    save(); render();
    return id;
  }

  function addLink(a, b){
    if (!a || !b || a === b) return;
    const exists = state.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    state.links.push({id: uid(), a, b});
    save(); render();
  }

  // ---------- selection ----------
  function clearSelection(){
    selectedNodeId = null;
    selectedLinkId = null;
    selectedGroupId = null;
    render();
  }
  function selectNode(id){
    selectedNodeId = id;
    selectedLinkId = null;
    selectedGroupId = null;
    render();
  }
  function selectLink(id){
    selectedLinkId = id;
    selectedNodeId = null;
    selectedGroupId = null;
    render();
  }
  function selectGroup(id){
    selectedGroupId = id;
    selectedNodeId = null;
    selectedLinkId = null;
    render();
  }
  function toggleMulti(id){
    if (multi.has(id)) multi.delete(id);
    else multi.add(id);
    selectedNodeId = id;
    selectedLinkId = null;
    selectedGroupId = null;
    render();
  }

  // ---------- groups ----------
  function computeGroupBounds(groupId){
    const members = state.nodes.filter(n => n.groupId === groupId);
    if (!members.length) return null;

    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const n of members){
      minX = Math.min(minX, n.x);
      minY = Math.min(minY, n.y);
      maxX = Math.max(maxX, n.x + n.w);
      maxY = Math.max(maxY, n.y + n.h);
    }
    const g = getGroup(groupId);
    const pad = (g && typeof g.pad === "number") ? g.pad : 30;

    return {
      x: minX - pad,
      y: minY - pad - 18,
      w: (maxX - minX) + pad*2,
      h: (maxY - minY) + pad*2 + 18
    };
  }

  function pickPalettePrompt(){
    const msg =
`–í—ã–±–µ—Ä–∏ —Å—Ç–∏–ª—å (–≤–≤–µ–¥–∏ –Ω–æ–º–µ—Ä):
1) Sky
2) Rose
3) Lime
4) Amber
5) Violet
6) Slate`;
    const ans = prompt(msg, "1");
    if (ans === null) return null;
    const i = Math.max(1, Math.min(6, parseInt(ans,10) || 1)) - 1;
    return PALETTE[i];
  }

  function createGroupFromMulti(){
    const ids = [...multi];
    if (ids.length < 2){
      showToast("–ù—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å 2+ —É–∑–ª–∞ (Ctrl/‚åò+–∫–ª–∏–∫)");
      return;
    }
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã:", "–ì—Ä—É–ø–ø–∞");
    if (name === null) return;

    const pal = pickPalettePrompt();
    if (!pal) return;

    const gid = uid();
    state.groups.push({
      id: gid,
      name: (name || "–ì—Ä—É–ø–ø–∞").trim() || "–ì—Ä—É–ø–ø–∞",
      style: {fill: pal.fill, stroke: pal.stroke},
      pad: 30
    });

    ids.forEach(id => { const n = getNode(id); if (n) n.groupId = gid; });
    multi.clear();
    selectGroup(gid);
    save(); render();
    showToast("–ì—Ä—É–ø–ø–∞ —Å–æ–∑–¥–∞–Ω–∞");
  }

  // ---------- delete ----------
  function deleteSelected(){
    if (selectedGroupId){
      const gid = selectedGroupId;
      state.nodes.forEach(n => { if (n.groupId === gid) n.groupId = null; });
      state.groups = state.groups.filter(g => g.id !== gid);
      selectedGroupId = null;
      save(); render();
      showToast("–ì—Ä—É–ø–ø–∞ —É–¥–∞–ª–µ–Ω–∞");
      return;
    }

    if (multi.size){
      const ids = new Set(multi);
      state.links = state.links.filter(l => !ids.has(l.a) && !ids.has(l.b));
      state.nodes = state.nodes.filter(n => !ids.has(n.id));
      multi.clear();
      selectedNodeId = null;
      save(); render();
      showToast("–£–∑–ª—ã —É–¥–∞–ª–µ–Ω—ã");
      return;
    }

    if (selectedNodeId){
      const id = selectedNodeId;
      state.links = state.links.filter(l => l.a !== id && l.b !== id);
      state.nodes = state.nodes.filter(n => n.id !== id);
      selectedNodeId = null;
      save(); render();
      showToast("–£–∑–µ–ª —É–¥–∞–ª—ë–Ω");
      return;
    }

    if (selectedLinkId){
      state.links = state.links.filter(l => l.id !== selectedLinkId);
      selectedLinkId = null;
      save(); render();
      showToast("–°–≤—è–∑—å —É–¥–∞–ª–µ–Ω–∞");
      return;
    }

    showToast("–ù–µ—á–µ–≥–æ —É–¥–∞–ª—è—Ç—å");
  }

  // ---------- persistence ----------
  function save(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){}
  }

  function migrateIfNeeded(){
    const v2 = localStorage.getItem(STORAGE_KEY);
    if (v2) return;

    const v1 = localStorage.getItem(OLD_KEY);
    if (!v1) return;

    try{
      const old = JSON.parse(v1);
      if (!old || !Array.isArray(old.nodes) || !Array.isArray(old.links)) return;

      state.nodes = old.nodes.map(n => {
        const {w,h} = measureNode(n.text || "–ò–¥–µ—è", n.note || "");
        return {
          id: n.id || uid(),
          x: Number(n.x)||0,
          y: Number(n.y)||0,
          text: n.text || "–ò–¥–µ—è",
          note: n.note || "",
          w: n.w || w,
          h: n.h || h,
          icon: "üí°",
          style: {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
          groupId: null
        };
      });
      state.links = old.links.map(l => ({id: l.id || uid(), a: l.a, b: l.b})).filter(l => l.a && l.b);
      state.groups = [];
      state.view = old.view || {x:20,y:20,k:1};
      save();
    }catch(e){}
  }

  function load(){
    try{
      migrateIfNeeded();
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const obj = JSON.parse(raw);
      if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.links)) return false;

      state = obj;
      state.groups ||= [];
      state.view ||= {x:20,y:20,k:1};

      state.nodes.forEach(n => {
        n.text ||= "–ò–¥–µ—è";
        n.note ||= "";
        const {w,h} = measureNode(n.text, n.note);
        n.w ||= w; n.h ||= h;
        n.icon = (typeof n.icon === "string") ? n.icon : "";
        if (!n.style) n.style = {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke};
        if (!("groupId" in n)) n.groupId = null;
      });

      state.groups.forEach(g => {
        g.name ||= "–ì—Ä—É–ø–ø–∞";
        g.pad = typeof g.pad === "number" ? g.pad : 30;
        if (!g.style) g.style = {fill:"rgba(255,255,255,.05)", stroke:"rgba(255,255,255,.22)"};
      });

      return true;
    }catch(e){ return false; }
  }

  function exportJSON(){
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "mindmap.json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  }

  function importJSON(file){
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.links)) throw new Error("bad");

        obj.groups ||= [];
        obj.view ||= {x:20,y:20,k:1};

        obj.nodes.forEach(n => {
          n.text ||= "–ò–¥–µ—è";
          n.note ||= "";
          const {w,h} = measureNode(n.text, n.note);
          n.w ||= w; n.h ||= h;
          n.icon = (typeof n.icon === "string") ? n.icon : "";
          if (!n.style) n.style = {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke};
          if (!("groupId" in n)) n.groupId = null;
        });

        obj.groups.forEach(g => {
          g.name ||= "–ì—Ä—É–ø–ø–∞";
          g.pad = typeof g.pad === "number" ? g.pad : 30;
          if (!g.style) g.style = {fill:"rgba(255,255,255,.05)", stroke:"rgba(255,255,255,.22)"};
        });

        state = obj;
        selectedNodeId = null; selectedLinkId = null; selectedGroupId = null;
        multi.clear();
        save(); render();
        showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
      }catch(e){
        showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å JSON");
      }
    };
    fr.readAsText(file);
  }

  // ---------- svg helpers ----------
  function el(name, attrs={}){
    const x = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) x.setAttribute(k, String(v));
    return x;
  }

  // ---------- render ----------
  function render(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const gView = el("g", { transform: `translate(${state.view.x},${state.view.y}) scale(${state.view.k})` });
    svg.appendChild(gView);

    // groups (behind)
    state.groups.forEach(gr => {
      const b = computeGroupBounds(gr.id);
      if (!b) return;

      const gg = el("g", {
        class: "group" + (gr.id === selectedGroupId ? " selected" : ""),
        transform: `translate(${b.x},${b.y})`,
        "data-group-id": gr.id
      });

      const rect = el("rect", {
        width: b.w,
        height: b.h,
        style: `fill:${gr.style.fill};stroke:${gr.style.stroke};`
      });

      const badgeW = Math.max(70, (gr.name||"").length * 7.2 + 28);
      const badge = el("rect", {
        class:"groupBadge",
        x: 14, y: 12, width: badgeW, height: 22,
        style: `fill: rgba(0,0,0,.28); stroke: rgba(255,255,255,.14);`
      });

      const label = el("text", { class:"groupLabel", x: 28, y: 23 });
      label.textContent = gr.name || "–ì—Ä—É–ø–ø–∞";

      gg.appendChild(rect);
      gg.appendChild(badge);
      gg.appendChild(label);

      gg.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        selectGroup(gr.id);
        const members = state.nodes.filter(n => n.groupId === gr.id).map(n => n.id);
        drag = { type:"group", id: gr.id, movedIds: members, sx:e.clientX, sy:e.clientY, base:null };
        svg.setPointerCapture(e.pointerId);
      });

      gView.appendChild(gg);
    });

    // links
    state.links.forEach(l => {
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) return;

      const ax = a.x + a.w/2, ay = a.y + a.h/2;
      const bx = b.x + b.w/2, by = b.y + b.h/2;

      const dx = (bx - ax);
      const c1x = ax + dx * 0.33;
      const c2x = ax + dx * 0.66;
      const d = `M ${ax} ${ay} C ${c1x} ${ay}, ${c2x} ${by}, ${bx} ${by}`;

      const path = el("path", {
        d,
        class: "link" + (l.id === selectedLinkId ? " selected" : ""),
        "data-link-id": l.id
      });
      path.addEventListener("pointerdown", (e) => { e.stopPropagation(); selectLink(l.id); });
      gView.appendChild(path);
    });

    // draft link
    if (linkDraft && linkDraft.fromId){
      const from = getNode(linkDraft.fromId);
      if (from){
        const ax = from.x + from.w/2, ay = from.y + from.h/2;
        const bx = linkDraft.x, by = linkDraft.y;
        const dx = (bx-ax);
        const d = `M ${ax} ${ay} C ${ax+dx*0.33} ${ay}, ${ax+dx*0.66} ${by}, ${bx} ${by}`;
        gView.appendChild(el("path", { d, class:"link", opacity:"0.6", "stroke-dasharray":"6 6" }));
      }
    }

    // nodes
    state.nodes.forEach(n => {
      const isSel = (n.id === selectedNodeId);
      const isMulti = multi.has(n.id);

      const gn = el("g", {
        class: "node" + (isSel ? " selected" : "") + (isMulti ? " multi" : ""),
        transform: `translate(${n.x},${n.y})`,
        "data-node-id": n.id
      });

      const rect = el("rect", {
        width: n.w, height: n.h,
        style:
          `fill:${(n.style && n.style.fill) ? n.style.fill : "rgba(255,255,255,.07)"};`+
          `stroke:${(n.style && n.style.stroke) ? n.style.stroke : "rgba(255,255,255,.18)"};`
      });

      gn.appendChild(rect);

      const hasIcon = (n.icon && n.icon.trim().length > 0);
      const leftPad = hasIcon ? 36 : 14;

      if (hasIcon){
        const ic = el("text", { x: 14, y: n.h/2 - (n.note ? 8 : 0), class:"icon" });
        ic.textContent = n.icon;
        gn.appendChild(ic);
      }

      const title = el("text", { x: leftPad, y: n.h/2 - (n.note ? 8 : 0) });
      title.textContent = n.text || "–ò–¥–µ—è";
      gn.appendChild(title);

      if (n.note){
        const sub = el("text", { x: leftPad, y: n.h/2 + 14, class:"sub" });
        sub.textContent = n.note;
        gn.appendChild(sub);
      }

      // interactions
      gn.addEventListener("pointerdown", (e) => {
        e.stopPropagation();

        if (e.ctrlKey || e.metaKey){
          toggleMulti(n.id);
          svg.setPointerCapture(e.pointerId);
          return;
        }

        if (e.shiftKey){
          linkDraft = { fromId: n.id, x: (n.x + n.w/2), y: (n.y + n.h/2) };
          selectNode(n.id);
          svg.setPointerCapture(e.pointerId);
          return;
        }

        selectNode(n.id);

        const moveIds = (multi.size && multi.has(n.id)) ? [...multi] : [n.id];
        drag = {
          type: "node",
          movedIds: moveIds,
          sx: e.clientX, sy: e.clientY,
          base: moveIds.map(id => ({ id, x: getNode(id).x, y: getNode(id).y }))
        };
        svg.setPointerCapture(e.pointerId);
      });

      gn.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        selectNode(n.id);
        editSelected();
      });

      gView.appendChild(gn);
    });

    wrap.style.cursor = isSpaceDown ? "grab" : "default";
  }

  // ---------- edit ----------
  function editSelected(){
    const n = selectedNodeId ? getNode(selectedNodeId) : null;
    if (!n){ showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª"); return; }

    const title = prompt("–¢–µ–∫—Å—Ç —É–∑–ª–∞:", n.text ?? "");
    if (title === null) return;

    const note = prompt("–ü–æ–¥–ø–∏—Å—å (–≤—Ç–æ—Ä–∞—è —Å—Ç—Ä–æ–∫–∞, –º–æ–∂–Ω–æ –ø—É—Å—Ç–æ):", n.note ?? "");
    if (note === null) return;

    n.text = title.trim() || "–ò–¥–µ—è";
    n.note = (note || "").trim();
    const {w,h} = measureNode(n.text, n.note);
    n.w = w; n.h = h;

    save(); render();
  }

  // ---------- style ----------
  function styleSelected(){
    const ids = multi.size ? [...multi] : (selectedNodeId ? [selectedNodeId] : []);
    if (!ids.length){ showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª (–∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ Ctrl/‚åò+–∫–ª–∏–∫)"); return; }

    const icon = prompt("–ò–∫–æ–Ω–∫–∞ (emoji), –Ω–∞–ø—Ä–∏–º–µ—Ä: üí° ‚úÖ üß™ üéØ üìå (–ø—É—Å—Ç–æ ‚Äî —É–±—Ä–∞—Ç—å):", ids.length===1 ? (getNode(ids[0]).icon||"") : "üí°");
    if (icon === null) return;

    const pal = pickPalettePrompt();
    if (!pal) return;

    const assignGroup = prompt(
      "–ì—Ä—É–ø–ø–∞: –≤–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –≥—Ä—É–ø–ø—ã, –∏–ª–∏ –æ—Å—Ç–∞–≤—å –ø—É—Å—Ç–æ (–Ω–µ –º–µ–Ω—è—Ç—å).\n–ß—Ç–æ–±—ã —Å–Ω—è—Ç—å –≥—Ä—É–ø–ø—É ‚Äî –≤–≤–µ–¥–∏: NONE",
      ""
    );
    if (assignGroup === null) return;

    let mode = "keep";
    let targetGroupId = null;
    const txt = (assignGroup || "").trim();
    if (txt === "") mode = "keep";
    else if (txt.toUpperCase() === "NONE") mode = "clear";
    else {
      const g = state.groups.find(x => (x.name||"").toLowerCase() === txt.toLowerCase());
      if (!g){ showToast("–ì—Ä—É–ø–ø—ã —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º –Ω–µ—Ç (—Å–æ–∑–¥–∞–π —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –ì—Ä—É–ø–ø–∞)"); return; }
      targetGroupId = g.id;
      mode = "set";
    }

    ids.forEach(id => {
      const n = getNode(id);
      if (!n) return;
      n.icon = (icon || "").trim();
      n.style = {fill: pal.fill, stroke: pal.stroke};
      if (mode === "set") n.groupId = targetGroupId;
      if (mode === "clear") n.groupId = null;
    });

    save(); render();
    showToast("–°—Ç–∏–ª—å –ø—Ä–∏–º–µ–Ω—ë–Ω");
  }

  // ---------- auto layout ----------
  function autoLayout(){
    const rootId = selectedNodeId || (state.nodes[0] && state.nodes[0].id);
    if (!rootId){ showToast("–ù–µ—Ç —É–∑–ª–æ–≤"); return; }

    const adj = new Map();
    for (const n of state.nodes) adj.set(n.id, []);
    for (const l of state.links){
      if (!adj.has(l.a) || !adj.has(l.b)) continue;
      adj.get(l.a).push(l.b);
      adj.get(l.b).push(l.a);
    }

    const parent = new Map();
    const children = new Map();
    for (const n of state.nodes) children.set(n.id, []);
    parent.set(rootId, null);

    const q = [rootId];
    const seen = new Set([rootId]);
    while(q.length){
      const v = q.shift();
      for (const u of (adj.get(v)||[])){
        if (seen.has(u)) continue;
        seen.add(u);
        parent.set(u, v);
        children.get(v).push(u);
        q.push(u);
      }
    }

    const size = new Map();
    function dfs(v){
      let s = 1;
      for (const c of (children.get(v)||[])) s += dfs(c);
      size.set(v, s);
      return s;
    }
    dfs(rootId);

    const r = svg.getBoundingClientRect();
    const center = clientToWorld(r.left + r.width/2, r.top + r.height/2);

    const ring = 170;
    const jitter = 6;

    function place(v, depth, a0, a1){
      const n = getNode(v);
      if (!n) return;

      const ang = (a0 + a1) / 2;
      const rad = depth * ring;

      if (depth === 0){
        n.x = center.x - n.w/2;
        n.y = center.y - n.h/2;
      } else {
        const x = center.x + Math.cos(ang) * rad;
        const y = center.y + Math.sin(ang) * rad;
        n.x = x - n.w/2 + (Math.random()*2-1)*jitter;
        n.y = y - n.h/2 + (Math.random()*2-1)*jitter;
      }

      const kids = children.get(v) || [];
      if (!kids.length) return;

      const total = kids.reduce((acc,c)=> acc + (size.get(c)||1), 0);
      let cur = a0;
      for (const c of kids){
        const w = (size.get(c)||1) / total;
        const span = (a1 - a0) * w;
        const next = cur + span;
        place(c, depth+1, cur, next);
        cur = next;
      }
    }

    place(rootId, 0, -Math.PI + 0.2, Math.PI - 0.2);

    const placed = new Set([rootId]);
    for (const [k] of parent.entries()) placed.add(k);

    const unplaced = state.nodes.filter(n => !placed.has(n.id)).map(n=>n.id);
    if (unplaced.length){
      const baseR = 3 * ring;
      unplaced.forEach((id, i) => {
        const n = getNode(id);
        if (!n) return;
        const ang = (i / unplaced.length) * (Math.PI*2);
        const x = center.x + Math.cos(ang) * baseR + ring*1.2;
        const y = center.y + Math.sin(ang) * baseR;
        n.x = x - n.w/2;
        n.y = y - n.h/2;
      });
    }

    save(); render();
    showToast("–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –≥–æ—Ç–æ–≤–∞");
  }

  // ---------- hit tests ----------
  function findNodeFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-node-id");
      if (id) return id;
    }
    return null;
  }
  function findGroupFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-group-id");
      if (id) return id;
    }
    return null;
  }
  function findLinkFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-link-id");
      if (id) return id;
    }
    return null;
  }

  // ---------- pointer events ----------
  svg.addEventListener("pointerdown", (e) => {
    if (isSpaceDown){
      drag = { type:"pan", sx:e.clientX, sy:e.clientY, ox:state.view.x, oy:state.view.y };
      svg.setPointerCapture(e.pointerId);
      wrap.style.cursor = "grabbing";
      return;
    }

    const hitNode = findNodeFromEvent(e);
    const hitGroup = findGroupFromEvent(e);
    const hitLink = findLinkFromEvent(e);

    if (!hitNode && !hitGroup && !hitLink){
      multi.clear();
      clearSelection();
    }
  });

  svg.addEventListener("dblclick", (e) => {
    const p = clientToWorld(e.clientX, e.clientY);
    addNode(p.x - 60, p.y - 22, "–ù–æ–≤–∞—è –∏–¥–µ—è", "", "üí°", PALETTE[0]);
  });

  svg.addEventListener("pointermove", (e) => {
    if (!drag && !linkDraft) return;

    if (linkDraft){
      const p = clientToWorld(e.clientX, e.clientY);
      linkDraft.x = p.x;
      linkDraft.y = p.y;
      render();
      return;
    }

    if (drag.type === "node"){
      const dx = (e.clientX - drag.sx) / state.view.k;
      const dy = (e.clientY - drag.sy) / state.view.k;
      for (const b of drag.base){
        const n = getNode(b.id);
        if (!n) continue;
        n.x = b.x + dx;
        n.y = b.y + dy;
      }
      render();
      return;
    }

    if (drag.type === "group"){
      const dx = (e.clientX - drag.sx) / state.view.k;
      const dy = (e.clientY - drag.sy) / state.view.k;
      if (!drag.base){
        drag.base = (drag.movedIds||[]).map(id => {
          const n = getNode(id);
          return { id, x:n.x, y:n.y };
        });
      }
      for (const b of drag.base){
        const n = getNode(b.id);
        if (!n) continue;
        n.x = b.x + dx;
        n.y = b.y + dy;
      }
      render();
      return;
    }

    if (drag.type === "pan"){
      const dx = (e.clientX - drag.sx);
      const dy = (e.clientY - drag.sy);
      state.view.x = drag.ox + dx;
      state.view.y = drag.oy + dy;
      render();
      return;
    }
  });

  svg.addEventListener("pointerup", (e) => {
    if (linkDraft){
      const target = findNodeFromEvent(e);
      if (target && target !== linkDraft.fromId){
        addLink(linkDraft.fromId, target);
        showToast("–°–≤—è–∑—å —Å–æ–∑–¥–∞–Ω–∞");
      } else {
        showToast("–°–≤—è–∑—å –æ—Ç–º–µ–Ω–µ–Ω–∞");
      }
      linkDraft = null;
      save(); render();
      return;
    }

    if (drag){
      drag = null;
      save();
      render();
      wrap.style.cursor = isSpaceDown ? "grab" : "default";
    }
  });

  // long-press edit (mobile)
  svg.addEventListener("pointerdown", (e) => {
    const nodeId = findNodeFromEvent(e);
    if (!nodeId) return;
    clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      selectNode(nodeId);
      editSelected();
    }, 560);
  });
  svg.addEventListener("pointerup", () => clearTimeout(pressTimer));
  svg.addEventListener("pointercancel", () => clearTimeout(pressTimer));

  // ---------- zoom ----------
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;

    const before = clientToWorld(e.clientX, e.clientY);
    const nk = Math.max(0.25, Math.min(2.8, state.view.k * factor));

    const r = svg.getBoundingClientRect();
    const vx = e.clientX - r.left;
    const vy = e.clientY - r.top;

    state.view.k = nk;
    state.view.x = vx - before.x * nk;
    state.view.y = vy - before.y * nk;

    render(); save();
  }, {passive:false});

  // ---------- keys ----------
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space"){
      isSpaceDown = true;
      wrap.style.cursor = "grab";
      e.preventDefault();
    }
    if (e.key === "Delete" || e.key === "Backspace"){
      deleteSelected();
      e.preventDefault();
    }
    if (e.key === "Enter"){
      if (selectedNodeId) editSelected();
      e.preventDefault();
    }
    if (e.key === "Escape"){
      multi.clear();
      clearSelection();
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "e"){
      exportJSON(); e.preventDefault();
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "Space"){
      isSpaceDown = false;
      wrap.style.cursor = "default";
    }
  });

  // ---------- actions ----------
  document.getElementById("addRoot").addEventListener("click", () => {
    if (state.nodes.length === 0){
      addNode(240, 180, "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è", "Shift+–∫–ª–∏–∫: —Å–≤—è–∑—å ‚Ä¢ Ctrl/‚åò+–∫–ª–∏–∫: –º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä", "üéØ", PALETTE[0]);
      showToast("–°–æ–∑–¥–∞–Ω —Ü–µ–Ω—Ç—Ä");
    } else {
      const r = svg.getBoundingClientRect();
      const p = clientToWorld(r.left + r.width/2, r.top + r.height/2);
      addNode(p.x - 60, p.y - 22, "–ù–æ–≤–∞—è –∏–¥–µ—è", "", "üí°", PALETTE[0]);
      showToast("–î–æ–±–∞–≤–ª–µ–Ω —É–∑–µ–ª");
    }
  });

  document.getElementById("addChild").addEventListener("click", () => {
    if (!selectedNodeId){ showToast("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —Ä–æ–¥–∏—Ç–µ–ª—è"); return; }
    const parent = getNode(selectedNodeId);
    const pal = parent?.style ? parent.style : PALETTE[0];
    const id = addNode(parent.x + parent.w + 70, parent.y + 10, "–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è", "", "‚úÖ", pal);
    addLink(parent.id, id);
    showToast("–î–æ–±–∞–≤–ª–µ–Ω –¥–æ—á–µ—Ä–Ω–∏–π + —Å–≤—è–∑—å");
  });

  document.getElementById("autoLayout").addEventListener("click", autoLayout);

  document.getElementById("edit").addEventListener("click", () => {
    if (!selectedNodeId){ showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª"); return; }
    editSelected();
  });

  document.getElementById("setStyle").addEventListener("click", styleSelected);

  document.getElementById("makeGroup").addEventListener("click", createGroupFromMulti);

  document.getElementById("del").addEventListener("click", deleteSelected);

  document.getElementById("export").addEventListener("click", exportJSON);

  document.getElementById("importFile").addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) importJSON(f);
    e.target.value = "";
  });

  document.getElementById("resetView").addEventListener("click", () => {
    fitDefault();
    showToast("–í–∏–¥ —Å–±—Ä–æ—à–µ–Ω");
  });

  document.getElementById("clearAll").addEventListener("click", () => {
    if (!confirm("–£–¥–∞–ª–∏—Ç—å –≤—Å—ë?")) return;
    state.nodes = [];
    state.links = [];
    state.groups = [];
    selectedNodeId = null;
    selectedLinkId = null;
    selectedGroupId = null;
    multi.clear();
    fitDefault();
    save(); render();
    showToast("–û—á–∏—â–µ–Ω–æ");
  });

  // ---------- init ----------
  const ok = load();
  if (!ok){
    fitDefault();
    addNode(240, 180, "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è", "Shift+–∫–ª–∏–∫: —Å–≤—è–∑—å ‚Ä¢ Ctrl/‚åò+–∫–ª–∏–∫: –º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä", "üéØ", PALETTE[0]);
  } else {
    render();
  }

})();
</script>
</body>
</html>
