<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MindMap</title>
  <meta name="theme-color" content="#f3f7ff" />
  <style>
    :root{
      --text:#0b1324;
      --stroke:rgba(11,19,36,.12);
      --shadow: 0 18px 60px rgba(10,20,40,.14);
      --grid:rgba(10,20,40,.06);
      --tool:rgba(20,28,40,.88);
      --toolText:rgba(255,255,255,.92);
      --toolStroke:rgba(255,255,255,.10);
      --glass: rgba(255,255,255,.72);
      --glass2: rgba(255,255,255,.82);
      --triggerBg: rgba(20,28,40,.88);
      --triggerStroke: rgba(255,255,255,.14);
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1000px 700px at 20% 10%, rgba(89,195,255,.28), transparent 58%),
        radial-gradient(900px 650px at 85% 20%, rgba(255,92,122,.20), transparent 60%),
        radial-gradient(1000px 700px at 55% 95%, rgba(60,224,122,.22), transparent 60%),
        linear-gradient(180deg, #f7fbff, #eef4ff 55%, #f8fbff);
      overflow:hidden;
    }

    .app{ height:100%; display:flex; flex-direction:column; }

    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:100;
      background: var(--glass);
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }

    .btn, select{
      appearance:none;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.70);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.06);
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font: inherit;
      height: 38px;
    }
    select{ cursor:pointer; }
    .btn:hover, select:hover{ border-color: rgba(89,195,255,.45); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.55); }
    .btn.danger{ border-color: rgba(255,92,122,.55); }
    .sep{ width:1px; height:26px; background:var(--stroke); margin:0 2px; }

    .stageWrap{ flex:1; position:relative; overflow:hidden; }
    .stageWrap::before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 42px 42px, 7px 7px;
      opacity:.75;
      pointer-events:none;
      z-index:0;
    }

    .leftbar{
      position:absolute;
      left:14px; top:14px;
      z-index:80;
      background: var(--glass2);
      border:1px solid var(--stroke);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      backdrop-filter: blur(10px);
    }
    .toolbtn{
      width:44px; height:44px;
      border-radius:14px;
      border:1px solid rgba(11,19,36,.10);
      background: rgba(255,255,255,.78);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
      position:relative;
    }
    .toolbtn:hover{ border-color: rgba(89,195,255,.45); }
    .toolbtn.active{
      border-color: rgba(89,195,255,.8);
      box-shadow: 0 0 0 3px rgba(89,195,255,.18) inset;
    }
    .toolbtn span{ font-size:18px; }
    .toolhint{
      position:absolute;
      left:58px;
      top:50%;
      transform: translateY(-50%);
      background: rgba(20,28,40,.88);
      color: rgba(255,255,255,.92);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px;
      border-radius:12px;
      box-shadow: var(--shadow);
      white-space:nowrap;
      opacity:0;
      pointer-events:none;
      transition: .12s ease;
      z-index:120;
    }
    .toolbtn:hover .toolhint{ opacity:1; }

    #scene{
      position:absolute;
      inset:0;
      z-index:1;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }
    #scene.allowSelect{
      user-select:text;
      -webkit-user-select:text;
    }

    #world{
      position:absolute;
      left:0; top:0;
      transform-origin: 0 0;
      will-change: transform;
    }

    #links{
      position:absolute;
      left:0; top:0;
      overflow:visible;
      pointer-events:none;
    }
    .link{
      stroke: rgba(30,90,150,.40);
      stroke-width: 2.2;
      fill: none;
    }

    #nodes{
      position:absolute;
      left:0; top:0;
    }

    .node{
      position:absolute;
      border-radius: 16px;
      padding: 10px 12px;
      height: 58px;
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 16px 26px rgba(10,20,40,.14);
      border: 1.2px solid rgba(11,19,36,.18);
      background: rgba(255,255,255,.80);
      cursor: grab;
      user-select:none;
      -webkit-user-select:none;
      min-width: 150px;
      max-width: 360px;
    }
    .node.selected{
      border-color: rgba(89,195,255,.95);
      box-shadow: 0 16px 26px rgba(10,20,40,.14), 0 0 0 3px rgba(89,195,255,.18) inset;
    }
    .node:active{ cursor: grabbing; }

    .node .icon{
      width:20px; height:20px;
      display:flex; align-items:center; justify-content:center;
      font-size:18px; line-height:1;
      flex:0 0 auto;
    }
    .node .text{
      flex:1 1 auto;
      line-height:1.15;
      overflow:hidden;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
      word-break: break-word;
      cursor: default;
      text-align: left;
      font-weight: 400;
      font-style: normal;
    }

    .node.editing{
      cursor: text;
      user-select:text;
      -webkit-user-select:text;
    }
    .node.editing .text{
      outline: none;
      cursor: text;
      user-select:text;
      -webkit-user-select:text;
      -webkit-line-clamp: unset;
      display:block;
      overflow: visible;
      white-space: pre-wrap;
    }

    /* Collapse dot as hollow/filled circle */
    .collapseDot{
      position:absolute;
      width: 18px; height: 18px;
      border-radius: 999px;
      box-shadow: 0 10px 18px rgba(10,20,40,.12);
      cursor: pointer;
      user-select:none;
      -webkit-user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,.90);
      border: 2px solid rgba(11,19,36,.22);
    }
    .collapseDot .inner{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: transparent;
      opacity: .35;
    }
    .collapseDot.collapsed .inner{
      opacity: .70;
    }

    /* Small trigger (‚ãØ) under selected node */
    .menuTrigger{
      position:fixed;
      z-index:95;
      display:none;
      width: 34px; height: 24px;
      border-radius: 999px;
      background: var(--triggerBg);
      border:1px solid var(--triggerStroke);
      box-shadow: var(--shadow);
      color: rgba(255,255,255,.92);
      align-items:center;
      justify-content:center;
      font-size: 16px;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
      backdrop-filter: blur(10px);
    }
    .menuTrigger:hover{
      border-color: rgba(89,195,255,.45);
    }

    .ctx{
      position:fixed;
      z-index:96;
      background: var(--tool);
      color: var(--toolText);
      border:1px solid var(--toolStroke);
      border-radius:14px;
      box-shadow: var(--shadow);
      display:none;
      gap:6px;
      padding:8px;
      align-items:center;
      backdrop-filter: blur(10px);
      user-select:none;
      -webkit-user-select:none;
    }
    .ctx .cbtn{
      width:34px; height:34px;
      display:flex; align-items:center; justify-content:center;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      font-size:16px;
    }
    .ctx .cbtn:hover{ border-color: rgba(89,195,255,.50); }
    .ctx .cbtn.on{
      border-color: rgba(89,195,255,.70);
      box-shadow: 0 0 0 2px rgba(89,195,255,.18) inset;
    }
    .ctx .csep{ width:1px; height:22px; background: rgba(255,255,255,.12); margin:0 2px; }
    .ctx .label{ font-size:12px; color: rgba(255,255,255,.70); padding:0 6px 0 2px; }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(255,255,255,.72);
      border:1px solid rgba(11,19,36,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(11,19,36,.86);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(720px, calc(100% - 24px));
      z-index:110;
    }
    .toast.show{ opacity:1; }

    input[type="file"]{ display:none; }
  </style>
</head>
<body>
<div class="app">
  <header id="topbar">
    <select id="projectSelect" title="–ú–∞–π–Ω–¥–º—ç–ø"></select>
    <button class="btn primary" id="projNew">+ –ù–æ–≤—ã–π</button>
    <button class="btn" id="projRename">–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å</button>
    <button class="btn" id="projDup">–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å</button>
    <button class="btn danger" id="projDel">–£–¥–∞–ª–∏—Ç—å</button>

    <div class="sep"></div>

    <button class="btn" id="autoLayout">–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞</button>
    <button class="btn" id="resetView">–°–±—Ä–æ—Å –≤–∏–¥–∞</button>

    <div class="sep"></div>

    <button class="btn" id="exportOne">–≠–∫—Å–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã</button>
    <label class="btn" for="importOne">–ò–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã</label>
    <input id="importOne" type="file" accept="application/json" />

    <button class="btn" id="exportAll">–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö</button>
    <label class="btn" for="importAll">–ò–º–ø–æ—Ä—Ç –≤—Å–µ—Ö</label>
    <input id="importAll" type="file" accept="application/json" />
  </header>

  <div class="stageWrap" id="wrap">
    <div class="leftbar" id="leftbar">
      <div class="toolbtn active" data-tool="select"><span>üñ±Ô∏è</span><div class="toolhint">Select (V)</div></div>
      <div class="toolbtn" data-tool="hand"><span>‚úã</span><div class="toolhint">Hand/Pan (H)</div></div>
      <div class="toolbtn" data-tool="node"><span>‚ûï</span><div class="toolhint">Add node (N) ‚Äî –∫–ª–∏–∫ –ø–æ –ø–æ–ª—é</div></div>
      <div class="toolbtn" data-tool="center"><span>üéØ</span><div class="toolhint">Center on selection (C)</div></div>
    </div>

    <!-- Trigger under selected node -->
    <div class="menuTrigger" id="menuTrigger" title="–ú–µ–Ω—é">‚ãØ</div>

    <!-- Context menu (opens only via trigger) -->
    <div class="ctx" id="ctx">
      <div class="label">–£–∑–µ–ª</div>
      <div class="cbtn" id="ctxChild" title="–î–æ—á–µ—Ä–Ω–∏–π">‚Ü≥</div>
      <div class="cbtn" id="ctxSibling" title="–°–æ—Å–µ–¥–Ω–∏–π">‚Ü¶</div>
      <div class="cbtn" id="ctxRename" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úèÔ∏è</div>

      <div class="csep"></div>

      <div class="cbtn" id="ctxBold" title="–ñ–∏—Ä–Ω—ã–π"><b>B</b></div>
      <div class="cbtn" id="ctxItalic" title="–ö—É—Ä—Å–∏–≤"><i>I</i></div>
      <div class="csep"></div>
      <div class="cbtn" id="ctxAlignL" title="–ü–æ –ª–µ–≤–æ–º—É">‚á§</div>
      <div class="cbtn" id="ctxAlignC" title="–ü–æ —Ü–µ–Ω—Ç—Ä—É">‚â°</div>
      <div class="cbtn" id="ctxAlignR" title="–ü–æ –ø—Ä–∞–≤–æ–º—É">‚á•</div>

      <div class="csep"></div>

      <div class="cbtn" id="ctxColor" title="–¶–≤–µ—Ç">üé®</div>
      <div class="cbtn" id="ctxIcon" title="–ò–∫–æ–Ω–∫–∞">üòä</div>
      <div class="cbtn" id="ctxCollapse" title="–°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å">‚§µÔ∏è</div>

      <div class="csep"></div>

      <div class="cbtn" id="ctxDelete" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</div>
      <div class="cbtn" id="ctxClose" title="–ó–∞–∫—Ä—ã—Ç—å">‚úñ</div>
    </div>

    <div id="scene">
      <div id="world">
        <svg id="links" xmlns="http://www.w3.org/2000/svg"></svg>
        <div id="nodes"></div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  const STORE_KEY = "mindmap_projects_v4";

  const PALETTE = [
    {name:"Sky",    fill:"rgba(89,195,255,.20)", stroke:"rgba(33,140,210,.62)"},
    {name:"Rose",   fill:"rgba(255,92,122,.18)", stroke:"rgba(230,70,95,.64)"},
    {name:"Lime",   fill:"rgba(60,224,122,.18)", stroke:"rgba(30,170,85,.62)"},
    {name:"Amber",  fill:"rgba(255,209,102,.20)", stroke:"rgba(205,150,40,.64)"},
    {name:"Violet", fill:"rgba(176,122,255,.18)", stroke:"rgba(135,90,210,.64)"},
    {name:"Slate",  fill:"rgba(255,255,255,.80)", stroke:"rgba(11,19,36,.18)"}
  ];
  const ICONS = ["üí°","‚úÖ","üéØ","üìå","üß†","‚ö°","üß©","üî•","üìé","üîó","‚≠ê","üìù","üìö","üß™","üêû","üß≠"];

  const wrap = document.getElementById("wrap");
  const topbar = document.getElementById("topbar");
  const scene = document.getElementById("scene");
  const world = document.getElementById("world");
  const linksSvg = document.getElementById("links");
  const nodesLayer = document.getElementById("nodes");
  const toast = document.getElementById("toast");

  const ctx = document.getElementById("ctx");
  const menuTrigger = document.getElementById("menuTrigger");
  let ctxOpen = false;

  const projectSelect = document.getElementById("projectSelect");
  const importOne = document.getElementById("importOne");
  const importAll = document.getElementById("importAll");

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);
  const nowTs = () => Date.now();

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 1400);
  }

  const measureCanvas = document.createElement("canvas");
  const mctx = measureCanvas.getContext("2d");
  const FONT = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
  function measureNode(text){
    mctx.font = FONT;
    const t = (text || "").trim() || "–ò–¥–µ—è";
    const raw = mctx.measureText(t).width;
    const minW = 150;
    const maxW = 360;
    const w = Math.max(minW, Math.min(maxW, Math.ceil(raw + 72)));
    const h = 58;
    return {w,h};
  }

  let store = null;
  let active = null;
  let map = null;

  let tool = "select";
  let selectedId = null;
  let editingId = null;

  const DRAG_THRESHOLD = 6;
  let drag = null;

  const pointers = new Map();
  let pinch = null;

  const tap = { id:null, count:0, t:0, timer:null };
  const TAP_WINDOW = 420;

  function saveStore(){
    try{ localStorage.setItem(STORE_KEY, JSON.stringify(store)); }catch(e){}
  }
  function loadStore(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (raw){
        const obj = JSON.parse(raw);
        if (obj && obj.projects && typeof obj.projects === "object") return obj;
      }
    }catch(e){}
    return null;
  }
  function normalizeMapData(data){
    data.view ||= {x:24,y:24,k:1};
    data.nodes ||= [];
    data.links ||= [];
    data.nodes.forEach(n => {
      n.text ||= "–ò–¥–µ—è";
      n.icon = (typeof n.icon === "string") ? n.icon : "üí°";
      n.style ||= { fill: PALETTE[0].fill, stroke: PALETTE[0].stroke };
      n.childColorNext ||= 0;
      n.parentId = n.parentId || null;
      n.collapsed = !!n.collapsed;

      // NEW: font style
      n.fmt ||= { bold:false, italic:false, align:"left" };

      const m = measureNode(n.text);
      n.w = m.w; n.h = m.h;
    });
    data.links = data.links.filter(l => l && l.a && l.b && l.a !== l.b);
    return data;
  }

  function createEmptyProject(name="–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø"){
    const id = uid();
    const data = normalizeMapData({ nodes: [], links: [], view:{x:24,y:24,k:1} });

    const centerId = uid();
    const m = measureNode("–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è");
    data.nodes.push({
      id:centerId, x:260, y:180, w:m.w, h:m.h,
      text:"–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è",
      icon:"üéØ",
      style:{fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
      childColorNext:0,
      parentId:null,
      collapsed:false,
      fmt:{bold:false, italic:false, align:"left"}
    });

    const p = { id, name, createdAt: nowTs(), updatedAt: nowTs(), data };
    store.projects[id] = p;
    store.activeId = id;
    saveStore();
    return p;
  }

  function rebuildProjectSelect(){
    projectSelect.innerHTML = "";
    const ids = Object.keys(store.projects)
      .map(id => store.projects[id])
      .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0))
      .map(p => p.id);

    for (const id of ids){
      const p = store.projects[id];
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è";
      if (id === store.activeId) opt.selected = true;
      projectSelect.appendChild(opt);
    }
  }

  function setActiveProject(id){
    const p = store.projects[id];
    if (!p) return;
    store.activeId = id;
    active = p;
    map = normalizeMapData(JSON.parse(JSON.stringify(p.data)));
    selectedId = null;
    editingId = null;
    drag = null;
    closeCtx();
    saveStore();
    rebuildProjectSelect();
    renderAll();
  }

  function commitMap(){
    if (!active) return;
    active.updatedAt = nowTs();
    active.data = JSON.parse(JSON.stringify(map));
    saveStore();
  }
  function autosave(){
    clearTimeout(autosave._t);
    autosave._t = setTimeout(() => commitMap(), 250);
  }

  function getNode(id){ return map.nodes.find(n => n.id === id); }
  function childrenOf(id){ return map.nodes.filter(n => n.parentId === id).map(n => n.id); }

  function isHiddenByCollapse(nodeId){
    let cur = getNode(nodeId);
    while(cur && cur.parentId){
      const p = getNode(cur.parentId);
      if (p && p.collapsed) return true;
      cur = p;
    }
    return false;
  }

  function addLink(a,b){
    if (!a || !b || a===b) return;
    const exists = map.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    map.links.push({ id: uid(), a, b });
  }

  function addNodeAt(x,y, text="–ù–æ–≤–∞—è –∏–¥–µ—è", icon="üí°", style=PALETTE[0]){
    drag = null;
    const m = measureNode(text);
    const id = uid();
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text, icon,
      style: {fill: style.fill, stroke: style.stroke},
      childColorNext: 0,
      parentId: null,
      collapsed: false,
      fmt:{bold:false, italic:false, align:"left"}
    });
    selectedId = id;
    closeCtx();
    autosave();
    renderAll();
    return id;
  }

  function addChildFrom(parentId){
    const parent = getNode(parentId);
    if (!parent) return null;
    drag = null;

    const idx = ((parent.childColorNext||0) + 1) % PALETTE.length;
    parent.childColorNext = (parent.childColorNext||0) + 1;
    const style = PALETTE[idx];

    const x = parent.x + parent.w + 140;
    const y = parent.y + (Math.random()*70 - 35);

    const id = uid();
    const m = measureNode("–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è");
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text:"–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è",
      icon:"‚úÖ",
      style:{fill: style.fill, stroke: style.stroke},
      childColorNext: 0,
      parentId: parentId,
      collapsed:false,
      fmt:{bold:false, italic:false, align:"left"}
    });
    addLink(parentId, id);

    selectedId = id;
    closeCtx();
    autosave();
    renderAll();
    return id;
  }

  function addSiblingFrom(nodeId){
    const n = getNode(nodeId);
    if (!n) return null;
    drag = null;

    const parentId = n.parentId || null;
    const x = n.x;
    const y = n.y + n.h + 18;

    const id = uid();
    const m = measureNode("–ù–æ–≤–∞—è –∏–¥–µ—è");
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text:"–ù–æ–≤–∞—è –∏–¥–µ—è",
      icon: n.icon || "üí°",
      style: n.style ? {fill:n.style.fill, stroke:n.style.stroke} : {fill:PALETTE[0].fill, stroke:PALETTE[0].stroke},
      childColorNext: 0,
      parentId,
      collapsed:false,
      fmt:{bold:false, italic:false, align:"left"}
    });
    if (parentId) addLink(parentId, id);

    selectedId = id;
    closeCtx();
    autosave();
    renderAll();
    return id;
  }

  function deleteSubtree(id){
    drag = null;
    const ids = new Set();
    const stack = [id];
    while(stack.length){
      const v = stack.pop();
      ids.add(v);
      for (const c of childrenOf(v)) stack.push(c);
    }
    map.nodes = map.nodes.filter(n => !ids.has(n.id));
    map.links = map.links.filter(l => !ids.has(l.a) && !ids.has(l.b));
    if (selectedId && ids.has(selectedId)) selectedId = null;
    closeCtx();
    autosave();
    renderAll();
  }

  function toggleCollapse(id){
    const n = getNode(id);
    if (!n) return;
    n.collapsed = !n.collapsed;
    autosave();
    renderAll();
  }

  function applyTransform(){
    const v = map.view;
    world.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.k})`;
  }

  function clientToWorld(cx, cy){
    const r = scene.getBoundingClientRect();
    const v = map.view;
    return {
      x: (cx - r.left - v.x) / v.k,
      y: (cy - r.top  - v.y) / v.k
    };
  }

  function edgePoint(fromNode, toNode){
    const cx = fromNode.x + fromNode.w/2;
    const cy = fromNode.y + fromNode.h/2;
    const tx = toNode.x + toNode.w/2;
    const ty = toNode.y + toNode.h/2;
    let dx = tx - cx, dy = ty - cy;
    if (dx === 0 && dy === 0) { dx = 1; dy = 0; }

    const hw = fromNode.w/2, hh = fromNode.h/2;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const sx = adx ? (hw / adx) : Infinity;
    const sy = ady ? (hh / ady) : Infinity;
    const t = Math.min(sx, sy);
    return { x: cx + dx * t, y: cy + dy * t };
  }

  function drawLinks(){
    const maxX = Math.max(2000, ...map.nodes.map(n => n.x + n.w + 300));
    const maxY = Math.max(1400, ...map.nodes.map(n => n.y + n.h + 300));
    linksSvg.setAttribute("width", maxX);
    linksSvg.setAttribute("height", maxY);

    linksSvg.innerHTML = "";
    for (const l of map.links){
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) continue;
      if (isHiddenByCollapse(a.id) || isHiddenByCollapse(b.id)) continue;

      const p1 = edgePoint(a, b);
      const p2 = edgePoint(b, a);
      const dx = p2.x - p1.x;
      const c1x = p1.x + dx * 0.33;
      const c2x = p1.x + dx * 0.66;
      const d = `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("class","link");
      linksSvg.appendChild(path);
    }
  }

  function renderSelectionOnly(){
    [...nodesLayer.querySelectorAll(".node")].forEach(el => {
      el.classList.toggle("selected", el.getAttribute("data-id") === selectedId);
    });
  }

  function applyNodeFmt(nodeEl, n){
    const textEl = nodeEl.querySelector(".text");
    const fmt = n.fmt || {bold:false, italic:false, align:"left"};
    textEl.style.fontWeight = fmt.bold ? "700" : "400";
    textEl.style.fontStyle = fmt.italic ? "italic" : "normal";
    textEl.style.textAlign = fmt.align || "left";
  }

  function renderNodes(){
    nodesLayer.innerHTML = "";

    for (const n of map.nodes){
      if (isHiddenByCollapse(n.id)) continue;

      const div = document.createElement("div");
      div.className = "node" + (n.id === selectedId ? " selected" : "");
      div.style.left = n.x + "px";
      div.style.top  = n.y + "px";
      div.style.width = n.w + "px";
      div.style.height = n.h + "px";
      div.style.background = n.style?.fill || "rgba(255,255,255,.80)";
      div.style.borderColor = n.style?.stroke || "rgba(11,19,36,.18)";
      div.setAttribute("data-id", n.id);

      const icon = document.createElement("div");
      icon.className = "icon";
      icon.textContent = n.icon || "";

      const text = document.createElement("div");
      text.className = "text";
      text.textContent = n.text || "";

      div.appendChild(icon);
      div.appendChild(text);
      applyNodeFmt(div, n);

      // Click selects ONLY (does not open menu)
      div.addEventListener("pointerdown", (e) => {
        if (editingId) return;
        e.preventDefault();

        selectedId = n.id;
        ctxOpen = false;
        ctx.style.display = "none";
        renderSelectionOnly();
        positionTriggerAndCtx();
        updateCtxToggles();
      });

      // Drag move
      div.addEventListener("pointerdown", (e) => {
        if (editingId) return;
        // already prevented default above, but keep flow safe
        drag = {
          kind: "node",
          nodeId: n.id,
          pointerId: e.pointerId,
          sx: e.clientX, sy: e.clientY,
          moved: false,
          baseX: n.x, baseY: n.y
        };
        div.setPointerCapture(e.pointerId);
      }, {passive:false});

      div.addEventListener("pointermove", (e) => {
        if (!drag || drag.kind !== "node" || drag.pointerId !== e.pointerId || drag.nodeId !== n.id) return;

        const dx = e.clientX - drag.sx;
        const dy = e.clientY - drag.sy;
        const dist = Math.hypot(dx, dy);
        if (!drag.moved && dist > DRAG_THRESHOLD) drag.moved = true;
        if (!drag.moved) return;

        const node = getNode(drag.nodeId);
        if (!node) return;

        node.x = drag.baseX + dx / map.view.k;
        node.y = drag.baseY + dy / map.view.k;

        div.style.left = node.x + "px";
        div.style.top  = node.y + "px";

        const dot = nodesLayer.querySelector(`.collapseDot[data-dot-for="${CSS.escape(node.id)}"]`);
        if (dot){
          dot.style.left = (node.x + node.w + 10) + "px";
          dot.style.top  = (node.y + node.h/2 - 9) + "px";
        }

        drawLinks();
        positionTriggerAndCtx();
        autosave();
      });

      function endNodeDrag(e){
        if (drag && drag.kind === "node" && drag.pointerId === e.pointerId){
          drag = null;
        }
      }

      // Double/Triple click logic (microstep)
      div.addEventListener("pointerup", (e) => {
        const moved = !!(drag && drag.kind === "node" && drag.pointerId === e.pointerId && drag.moved);
        endNodeDrag(e);
        if (editingId) return;
        if (moved) return;

        const now = Date.now();
        const same = (tap.id === n.id) && (now - tap.t <= TAP_WINDOW);
        tap.id = n.id;
        tap.t = now;
        tap.count = same ? (tap.count + 1) : 1;

        if (tap.timer) clearTimeout(tap.timer);
        tap.timer = setTimeout(() => {
          if (tap.id !== n.id) return;

          // DOUBLE CLICK: create child + start editing it
          if (tap.count === 2){
            const childId = addChildFrom(n.id);
            if (childId){
              // open edit instantly
              beginEdit(childId, true);
            }
          }
          // TRIPLE+: edit this node
          else if (tap.count >= 3){
            beginEdit(n.id, true);
          }

          tap.id = null; tap.count = 0; tap.timer = null;
        }, TAP_WINDOW + 30);
      });

      div.addEventListener("pointercancel", endNodeDrag);
      div.addEventListener("lostpointercapture", endNodeDrag);

      nodesLayer.appendChild(div);

      // Collapse dot (tree)
      const kids = childrenOf(n.id);
      if (kids.length){
        const dot = document.createElement("div");
        dot.className = "collapseDot" + (n.collapsed ? " collapsed" : "");
        dot.setAttribute("data-dot-for", n.id);
        dot.style.left = (n.x + n.w + 10) + "px";
        dot.style.top  = (n.y + n.h/2 - 9) + "px";

        const stroke = (n.style && n.style.stroke) ? n.style.stroke : "rgba(11,19,36,.22)";
        dot.style.borderColor = stroke;

        const inner = document.createElement("div");
        inner.className = "inner";
        inner.style.background = stroke;
        dot.appendChild(inner);

        dot.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          toggleCollapse(n.id);
        });

        nodesLayer.appendChild(dot);
      }
    }
  }

  function renderAll(){
    applyTransform();
    drawLinks();
    renderNodes();
    positionTriggerAndCtx();
    updateCtxToggles();
  }

  function closeCtx(){
    ctxOpen = false;
    ctx.style.display = "none";
    menuTrigger.style.display = "none";
  }

  // Trigger + menu positioning (relative to selected node)
  function positionTriggerAndCtx(){
    if (!selectedId) { closeCtx(); return; }

    const nodeEl = nodesLayer.querySelector(`.node[data-id="${CSS.escape(selectedId)}"]`);
    const n = getNode(selectedId);
    if (!nodeEl || !n || isHiddenByCollapse(selectedId)) { closeCtx(); return; }

    const rect = nodeEl.getBoundingClientRect();
    const headerRect = topbar.getBoundingClientRect();
    const safeTop = headerRect.bottom + 6;

    // Trigger under node, centered
    const trigW = 34, trigH = 24, trigGap = 2;
    let tx = rect.left + rect.width/2 - trigW/2;
    let ty = rect.bottom + trigGap;

    // If trigger would go outside bottom, place it above node
    if (ty + trigH > window.innerHeight - 8){
      ty = rect.top - trigH - trigGap;
    }
    // Keep it below header if placed above
    ty = Math.max(safeTop, ty);

    tx = Math.max(10, Math.min(window.innerWidth - trigW - 10, tx));

    menuTrigger.style.left = tx + "px";
    menuTrigger.style.top  = ty + "px";
    menuTrigger.style.display = "flex";

    // Menu pops near trigger (not far)
    const ctxW = 520; // wide because we added typography controls
    const ctxH = 52;
    const gap = 4;

    let cx = rect.left + rect.width/2 - ctxW/2;
    cx = Math.max(12, Math.min(window.innerWidth - ctxW - 12, cx));

    // Prefer below trigger
    let cy = ty + trigH + gap;
    // If not enough space, place above trigger
    if (cy + ctxH > window.innerHeight - 8){
      cy = ty - ctxH - gap;
    }
    cy = Math.max(safeTop, cy);

    ctx.style.left = cx + "px";
    ctx.style.top  = cy + "px";
    ctx.style.display = ctxOpen ? "flex" : "none";
  }

  menuTrigger.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!selectedId) return;
    ctxOpen = !ctxOpen;
    positionTriggerAndCtx();
    updateCtxToggles();
  });

  // Clicking outside closes menu (but keeps selection)
  document.addEventListener("pointerdown", (e) => {
    if (e.target.closest(".ctx") || e.target.closest(".menuTrigger")) return;
    if (ctxOpen){
      ctxOpen = false;
      positionTriggerAndCtx();
    }
  });

  function updateCtxToggles(){
    const n = selectedId ? getNode(selectedId) : null;
    if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"left"};

    document.getElementById("ctxBold").classList.toggle("on", !!n.fmt.bold);
    document.getElementById("ctxItalic").classList.toggle("on", !!n.fmt.italic);

    document.getElementById("ctxAlignL").classList.toggle("on", (n.fmt.align||"left")==="left");
    document.getElementById("ctxAlignC").classList.toggle("on", (n.fmt.align||"left")==="center");
    document.getElementById("ctxAlignR").classList.toggle("on", (n.fmt.align||"left")==="right");
  }

  // ===== Inline edit =====
  function selectAllIn(el){
    const range = document.createRange();
    range.selectNodeContents(el);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function beginEdit(id, selectAll=false){
    if (editingId) return;
    const nodeEl = nodesLayer.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
    const n = getNode(id);
    if (!nodeEl || !n) return;

    drag = null;
    editingId = id;

    scene.classList.add("allowSelect");
    nodeEl.classList.add("editing");

    const textEl = nodeEl.querySelector(".text");
    textEl.contentEditable = "true";
    textEl.textContent = n.text || "";
    textEl.focus();

    if (selectAll) selectAllIn(textEl);

    const finish = (saveChanges) => {
      textEl.removeEventListener("keydown", onKey);
      textEl.removeEventListener("blur", onBlur);

      if (saveChanges){
        const val = (textEl.textContent || "").trim();
        n.text = val || "–ò–¥–µ—è";
        const m = measureNode(n.text);
        n.w = m.w; n.h = m.h;
      } else {
        textEl.textContent = n.text || "–ò–¥–µ—è";
      }

      textEl.contentEditable = "false";
      nodeEl.classList.remove("editing");
      editingId = null;

      scene.classList.remove("allowSelect");
      autosave();
      renderAll();
    };

    const onKey = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "a"){
        e.preventDefault();
        selectAllIn(textEl);
        return;
      }
      if (e.key === "Enter"){ e.preventDefault(); textEl.blur(); }
      if (e.key === "Escape"){ e.preventDefault(); finish(false); }
      e.stopPropagation();
    };

    const onBlur = () => finish(true);

    textEl.addEventListener("keydown", onKey);
    textEl.addEventListener("blur", onBlur);
  }

  // ===== Context actions =====
  document.getElementById("ctxChild").onclick = () => {
    if (!selectedId) return;
    const id = addChildFrom(selectedId);
    if (id) beginEdit(id, true);
  };
  document.getElementById("ctxSibling").onclick = () => {
    if (!selectedId) return;
    const id = addSiblingFrom(selectedId);
    if (id) beginEdit(id, true);
  };
  document.getElementById("ctxRename").onclick = () => { if (selectedId) beginEdit(selectedId, true); };

  document.getElementById("ctxBold").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"left"};
    n.fmt.bold = !n.fmt.bold;
    autosave(); renderAll();
  };
  document.getElementById("ctxItalic").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"left"};
    n.fmt.italic = !n.fmt.italic;
    autosave(); renderAll();
  };
  document.getElementById("ctxAlignL").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"left"};
    n.fmt.align = "left";
    autosave(); renderAll();
  };
  document.getElementById("ctxAlignC").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"left"};
    n.fmt.align = "center";
    autosave(); renderAll();
  };
  document.getElementById("ctxAlignR").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    n.fmt ||= {bold:false, italic:false, align:"left"};
    n.fmt.align = "right";
    autosave(); renderAll();
  };

  document.getElementById("ctxColor").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    const i = PALETTE.findIndex(p => p.fill === n.style.fill && p.stroke === n.style.stroke);
    const next = PALETTE[(Math.max(0,i)+1) % PALETTE.length];
    n.style = {fill: next.fill, stroke: next.stroke};
    autosave(); renderAll();
  };
  document.getElementById("ctxIcon").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    const i = ICONS.indexOf(n.icon);
    n.icon = ICONS[(i+1+ICONS.length) % ICONS.length];
    autosave(); renderAll();
  };
  document.getElementById("ctxCollapse").onclick = () => { if (selectedId) toggleCollapse(selectedId); };
  document.getElementById("ctxDelete").onclick = () => { if (selectedId) deleteSubtree(selectedId); };
  document.getElementById("ctxClose").onclick = () => { ctxOpen = false; positionTriggerAndCtx(); };

  // ===== Scene pan/zoom =====
  scene.addEventListener("pointerdown", (e) => {
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    const onNode = !!e.target.closest(".node") || !!e.target.closest(".collapseDot") || !!e.target.closest(".ctx") || !!e.target.closest(".menuTrigger");
    if (!onNode){
      if (editingId){
        const editor = nodesLayer.querySelector(`.node[data-id="${CSS.escape(editingId)}"] .text`);
        if (editor) editor.blur();
      }

      if (tool === "node"){
        const p = clientToWorld(e.clientX, e.clientY);
        addNodeAt(p.x - 90, p.y - 30, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
        return;
      }

      // clicking empty space deselects
      selectedId = null;
      ctxOpen = false;
      renderSelectionOnly();
      closeCtx();

      drag = {
        kind:"pan",
        pointerId:e.pointerId,
        sx:e.clientX, sy:e.clientY,
        moved:false,
        startViewX: map.view.x,
        startViewY: map.view.y
      };
      scene.setPointerCapture(e.pointerId);
    }

    if (pointers.size === 2){
      const pts = [...pointers.values()];
      pinch = {
        dist0: Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y),
        k0: map.view.k
      };
    }
  });

  scene.addEventListener("pointermove", (e) => {
    if (pointers.has(e.pointerId)) pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if (pointers.size === 2 && pinch){
      const pts = [...pointers.values()];
      const dist = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
      const scale = dist / Math.max(1, pinch.dist0);
      const nk = Math.max(0.25, Math.min(3.2, pinch.k0 * scale));

      const mid = {x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
      const before = clientToWorld(mid.x, mid.y);

      map.view.k = nk;
      const r = scene.getBoundingClientRect();
      const vx = mid.x - r.left;
      const vy = mid.y - r.top;
      map.view.x = vx - before.x * nk;
      map.view.y = vy - before.y * nk;

      applyTransform();
      positionTriggerAndCtx();
      autosave();
      return;
    }

    if (!drag || drag.pointerId !== e.pointerId) return;
    if (drag.kind !== "pan") return;

    const dx = e.clientX - drag.sx;
    const dy = e.clientY - drag.sy;
    const dist = Math.hypot(dx, dy);
    if (!drag.moved && dist > DRAG_THRESHOLD) drag.moved = true;
    if (!drag.moved) return;

    map.view.x = drag.startViewX + dx;
    map.view.y = drag.startViewY + dy;
    applyTransform();
    positionTriggerAndCtx();
    autosave();
  });

  scene.addEventListener("pointerup", (e) => {
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinch = null;
    if (drag && drag.kind === "pan" && drag.pointerId === e.pointerId) drag = null;
  });
  scene.addEventListener("pointercancel", (e) => {
    pointers.delete(e.pointerId);
    if (drag && drag.pointerId === e.pointerId) drag = null;
  });

  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;

    const before = clientToWorld(e.clientX, e.clientY);
    const nk = Math.max(0.25, Math.min(3.2, map.view.k * factor));

    const r = scene.getBoundingClientRect();
    const vx = e.clientX - r.left;
    const vy = e.clientY - r.top;

    map.view.k = nk;
    map.view.x = vx - before.x * nk;
    map.view.y = vy - before.y * nk;

    applyTransform();
    positionTriggerAndCtx();
    autosave();
  }, {passive:false});

  scene.addEventListener("dblclick", (e) => {
    if (e.target.closest(".node") || e.target.closest(".collapseDot") || e.target.closest(".ctx") || e.target.closest(".menuTrigger")) return;
    const p = clientToWorld(e.clientX, e.clientY);
    const id = addNodeAt(p.x - 90, p.y - 30, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
    beginEdit(id, true);
  });

  // Tools
  function setTool(t){
    tool = t;
    document.querySelectorAll(".toolbtn").forEach(b => b.classList.toggle("active", b.dataset.tool === t));
    if (t === "center") centerOnSelection();
  }
  document.getElementById("leftbar").addEventListener("click", (e) => {
    const btn = e.target.closest(".toolbtn");
    if (!btn) return;
    setTool(btn.dataset.tool);
  });

  function centerOnSelection(){
    if (!selectedId){ showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª"); setTool("select"); return; }
    const n = getNode(selectedId); if (!n) return;
    const r = scene.getBoundingClientRect();
    const cx = r.width/2, cy = r.height/2;
    map.view.x = cx - (n.x + n.w/2) * map.view.k;
    map.view.y = cy - (n.y + n.h/2) * map.view.k;
    applyTransform();
    positionTriggerAndCtx();
    autosave();
    setTool("select");
  }

  // Header actions
  projectSelect.addEventListener("change", () => setActiveProject(projectSelect.value));

  document.getElementById("projNew").onclick = () => {
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–∞–π–Ω–¥–º—ç–ø–∞:", "–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    const p = createEmptyProject((name || "–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø").trim());
    rebuildProjectSelect();
    setActiveProject(p.id);
    showToast("–°–æ–∑–¥–∞–Ω–æ");
  };

  document.getElementById("projRename").onclick = () => {
    if (!active) return;
    const name = prompt("–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", active.name || "–ú–∞–π–Ω–¥–º—ç–ø");
    if (!name) return;
    active.name = name.trim();
    active.updatedAt = nowTs();
    saveStore();
    rebuildProjectSelect();
    showToast("–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ");
  };

  document.getElementById("projDup").onclick = () => {
    if (!active) return;
    commitMap();
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ø–∏–∏:", (active.name || "–ú–∞–π–Ω–¥–º—ç–ø") + " (–∫–æ–ø–∏—è)");
    const id = uid();
    const clone = {
      id,
      name: (name || "–ö–æ–ø–∏—è").trim(),
      createdAt: nowTs(),
      updatedAt: nowTs(),
      data: JSON.parse(JSON.stringify(store.projects[store.activeId].data))
    };
    store.projects[id] = clone;
    store.activeId = id;
    saveStore();
    rebuildProjectSelect();
    setActiveProject(id);
    showToast("–î—É–±–ª–∏–∫–∞—Ç —Å–æ–∑–¥–∞–Ω");
  };

  document.getElementById("projDel").onclick = () => {
    if (!active) return;
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å "${active.name}"?`)) return;
    delete store.projects[active.id];
    const ids = Object.keys(store.projects);
    if (!ids.length){
      createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    } else {
      store.activeId = ids[0];
    }
    saveStore();
    rebuildProjectSelect();
    setActiveProject(store.activeId);
    showToast("–£–¥–∞–ª–µ–Ω–æ");
  };

  document.getElementById("autoLayout").onclick = () => {
    if (!map.nodes.length){ showToast("–ù–µ—Ç —É–∑–ª–æ–≤"); return; }
    const root = map.nodes.find(n => !n.parentId) || map.nodes[0];
    const r = scene.getBoundingClientRect();
    const center = clientToWorld(r.left + r.width/2, r.top + r.height/2);

    root.x = center.x - root.w/2;
    root.y = center.y - root.h/2;

    const kids = childrenOf(root.id).map(getNode).filter(Boolean);
    let y = root.y - (kids.length * 76)/2;
    for (const k of kids){
      k.x = root.x + root.w + 160;
      k.y = y;
      y += 76;
    }
    autosave();
    renderAll();
    showToast("–ì–æ—Ç–æ–≤–æ");
  };

  document.getElementById("resetView").onclick = () => {
    map.view = {x:24,y:24,k:1};
    applyTransform();
    positionTriggerAndCtx();
    autosave();
    showToast("–°–±—Ä–æ—à–µ–Ω–æ");
  };

  // Export/Import
  document.getElementById("exportOne").onclick = () => {
    if (!active) return;
    commitMap();
    const payload = { kind:"mindmap_project", version:4, project: store.projects[store.activeId] };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    const safe = (active.name || "mindmap").replace(/[^\w\d\-_.]+/g,"_");
    a.download = safe + ".json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  };

  importOne.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_project" || !obj.project) throw new Error("bad");
        const p = obj.project;
        if (!p.id) p.id = uid();
        p.data = normalizeMapData(p.data || {});
        p.createdAt ||= nowTs();
        p.updatedAt ||= nowTs();
        store.projects[p.id] = p;
        store.activeId = p.id;
        saveStore();
        rebuildProjectSelect();
        setActiveProject(p.id);
        showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
      }catch(err){
        showToast("–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
  });

  document.getElementById("exportAll").onclick = () => {
    commitMap();
    const payload = { kind:"mindmap_store", version:4, store };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "mindmaps_all.json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –≥–æ—Ç–æ–≤");
  };

  importAll.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_store" || !obj.store) throw new Error("bad");
        const s = obj.store;
        if (!s.projects || typeof s.projects !== "object") throw new Error("bad");
        Object.values(s.projects).forEach(p => {
          if (!p.id) p.id = uid();
          p.name ||= "–ú–∞–π–Ω–¥–º—ç–ø";
          p.createdAt ||= nowTs();
          p.updatedAt ||= nowTs();
          p.data = normalizeMapData(p.data || {});
        });
        store = s;
        if (!store.activeId || !store.projects[store.activeId]){
          store.activeId = Object.keys(store.projects)[0];
        }
        saveStore();
        rebuildProjectSelect();
        setActiveProject(store.activeId);
        showToast("–ò–º–ø–æ—Ä—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω");
      }catch(err){
        showToast("–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
  });

  // Shortcuts
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "v") setTool("select");
    if (k === "h") setTool("hand");
    if (k === "n") setTool("node");
    if (k === "c") setTool("center");

    if (e.key === "Tab" && selectedId && !editingId){
      e.preventDefault();
      const id = addChildFrom(selectedId);
      if (id) beginEdit(id, true);
    }
    if (e.key === "Enter" && selectedId && !editingId){
      e.preventDefault();
      const id = addSiblingFrom(selectedId);
      if (id) beginEdit(id, true);
    }
    if ((e.key === "Delete" || e.key === "Backspace") && selectedId && !editingId){
      e.preventDefault(); deleteSubtree(selectedId);
    }

    // ESC closes menu
    if (e.key === "Escape" && ctxOpen){
      ctxOpen = false;
      positionTriggerAndCtx();
    }
  });

  // ===== Init =====
  function init(){
    store = loadStore();
    if (!store){
      store = { activeId:null, projects:{} };
      createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    } else {
      if (!store.projects || Object.keys(store.projects).length === 0){
        store.projects = {};
        createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
      }
      if (!store.activeId || !store.projects[store.activeId]){
        store.activeId = Object.keys(store.projects)[0];
      }
    }
    saveStore();
    rebuildProjectSelect();
    setActiveProject(store.activeId);
  }

  init();
})();
</script>
</body>
</html>
