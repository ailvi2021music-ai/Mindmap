<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini MindMap (v3)</title>
  <meta name="theme-color" content="#0b1324" />
  <style>
    :root{
      --bg0:#070b16;
      --bg1:#0b1324;
      --panel:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.12);
      --text:#eaf2ff;
      --muted:rgba(234,242,255,.65);
      --accent:#59c3ff;
      --danger:#ff5c7a;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --radius:16px;
      --nodeRadius:14px;
      --grid:rgba(255,255,255,.05);
    }
    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(89,195,255,.18), transparent 55%),
        radial-gradient(900px 700px at 90% 20%, rgba(255,92,122,.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .app{ height:100%; display:flex; flex-direction:column; }

    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:20;
      background: linear-gradient(180deg, rgba(11,19,36,.92), rgba(11,19,36,.65));
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }
    .brand{ display:flex; flex-direction:column; gap:2px; margin-right:8px; }
    .brand b{ font-size:14px; letter-spacing:.2px; }
    .brand span{ color:var(--muted); font-size:12px; }

    .btn{
      appearance:none; border:1px solid var(--stroke); background:var(--panel);
      color:var(--text); padding:9px 10px; border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.25);
      cursor:pointer; user-select:none;
      display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{ border-color: rgba(89,195,255,.38); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.45); }
    .btn.danger{ border-color: rgba(255,92,122,.45); }
    .sep{ width:1px; height:26px; background:var(--stroke); margin:0 2px; }

    .stageWrap{ flex:1; position:relative; overflow:hidden; }
    .stageWrap::before{
      content:""; position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 36px 36px, 6px 6px;
      opacity:.35;
      pointer-events:none;
    }

    /* iOS/Safari fix: svg must be 100% */
    svg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      z-index:1;
    }

    .link{
      stroke: rgba(89,195,255,.60);
      stroke-width: 2.2;
      fill: none;
    }
    .link.selected{ stroke: rgba(255,92,122,.80); }

    .node{
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.45));
      cursor: grab;
    }
    .node.selected rect{
      stroke: rgba(89,195,255,.95) !important;
      stroke-width: 2.2 !important;
    }
    .node.multi rect{
      stroke: rgba(255,209,102,.95) !important;
      stroke-width: 2.2 !important;
    }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(234,242,255,.92);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(720px, calc(100% - 24px));
      z-index:30;
    }
    .toast.show{ opacity:1; }

    /* Inline editor */
    .editor{
      position:absolute;
      z-index:40;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      padding: 10px;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .editor input{
      width:100%;
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 10px;
      padding: 10px 12px;
      outline:none;
    }
    .editor .help{
      margin-top:8px;
      font-size:12px;
      color: rgba(234,242,255,.68);
    }

    input[type="file"]{ display:none; }

    @media (max-width: 560px){
      .brand span{ display:none; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <b>Mini MindMap</b>
      <span>–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫: –ø—É—Å—Ç–æ ‚Äî –Ω–æ–≤—ã–π —É–∑–µ–ª, –ø–æ —É–∑–ª—É ‚Äî –¥–æ—á–µ—Ä–Ω–∏–π. Enter ‚Äî –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å.</span>
    </div>

    <button class="btn primary" id="addRoot">+ –¶–µ–Ω—Ç—Ä</button>
    <button class="btn" id="addChild">+ –î–æ—á–µ—Ä–Ω–∏–π</button>
    <button class="btn" id="autoLayout">–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞</button>

    <div class="sep"></div>

    <button class="btn" id="rename">–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å</button>
    <button class="btn danger" id="del">–£–¥–∞–ª–∏—Ç—å</button>

    <div class="sep"></div>

    <button class="btn" id="export">–≠–∫—Å–ø–æ—Ä—Ç</button>
    <label class="btn" for="importFile">–ò–º–ø–æ—Ä—Ç</label>
    <input id="importFile" type="file" accept="application/json" />

    <div class="sep"></div>

    <button class="btn" id="resetView">–°–±—Ä–æ—Å –≤–∏–¥–∞</button>
    <button class="btn danger" id="clearAll">–û—á–∏—Å—Ç–∏—Ç—å</button>
  </header>

  <div class="stageWrap" id="wrap">
    <svg id="svg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg"></svg>
    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  const STORAGE_KEY = "mini_mindmap_v3";
  const OLD_KEY_V2 = "mini_mindmap_v2";
  const OLD_KEY_V1 = "mini_mindmap_v1";

  const svg = document.getElementById("svg");
  const wrap = document.getElementById("wrap");
  const toast = document.getElementById("toast");

  const PALETTE = [
    {name:"Sky",    fill:"rgba(89,195,255,.12)", stroke:"rgba(89,195,255,.65)"},
    {name:"Rose",   fill:"rgba(255,92,122,.11)", stroke:"rgba(255,92,122,.65)"},
    {name:"Lime",   fill:"rgba(60,224,122,.10)", stroke:"rgba(60,224,122,.65)"},
    {name:"Amber",  fill:"rgba(255,209,102,.10)", stroke:"rgba(255,209,102,.72)"},
    {name:"Violet", fill:"rgba(176,122,255,.10)", stroke:"rgba(176,122,255,.72)"},
    {name:"Slate",  fill:"rgba(255,255,255,.06)", stroke:"rgba(255,255,255,.22)"}
  ];

  let state = {
    nodes: [],   // {id,x,y,w,h,text,icon,style:{fill,stroke}, childColorNext}
    links: [],   // {id,a,b}
    view: {x:20,y:20,k:1}
  };

  let selectedNodeId = null;
  let selectedLinkId = null;
  let multi = new Set();

  let drag = null;       // {type:'node'|'pan', sx,sy, base:[{id,x,y}]}
  let linkDraft = null;  // reserved (not used now)
  let isSpaceDown = false;
  let editorEl = null;

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 1400);
  }

  // ---------- coords ----------
  function clientToWorld(cx, cy){
    const r = svg.getBoundingClientRect();
    return {
      x: (cx - r.left - state.view.x) / state.view.k,
      y: (cy - r.top  - state.view.y) / state.view.k
    };
  }
  function worldToClient(wx, wy){
    const r = svg.getBoundingClientRect();
    return {
      x: r.left + state.view.x + wx * state.view.k,
      y: r.top  + state.view.y + wy * state.view.k
    };
  }

  function setView(x, y, k){
    state.view.x = x;
    state.view.y = y;
    state.view.k = Math.max(0.25, Math.min(2.8, k));
    render(); save();
  }
  function fitDefault(){ setView(20,20,1); }

  // ---------- node sizing ----------
  function measureNode(text){
    // —à–∏—Ä–∏–Ω–∞ ‚Äî –ø–æ –¥–ª–∏–Ω–µ —Å—Ç—Ä–æ–∫–∏, –≤—ã—Å–æ—Ç–∞ ‚Äî —Ñ–∏–∫—Å (—Ç–µ–∫—Å—Ç –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–∏)
    const baseW = 180;
    const maxW  = 320;
    const approx = Math.min(maxW, Math.max(baseW, (text||"").length * 7.2 + 70));
    const w = approx;
    const h = 56;
    return {w,h};
  }

  function defaultStyle(){ return PALETTE[0]; }

  function getNode(id){ return state.nodes.find(n => n.id === id); }
  function getLink(id){ return state.links.find(l => l.id === id); }

  function addNode(x, y, text="–ù–æ–≤–∞—è –∏–¥–µ—è", icon="üí°", style=defaultStyle()){
    const {w,h} = measureNode(text);
    const id = uid();
    state.nodes.push({
      id, x, y, w, h,
      text,
      icon: (icon||"").trim(),
      style: {fill: style.fill, stroke: style.stroke},
      childColorNext: 0
    });
    selectNode(id);
    save(); render();
    return id;
  }

  function addLink(a, b){
    if (!a || !b || a===b) return;
    const exists = state.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    state.links.push({id: uid(), a, b});
    save(); render();
  }

  // ---------- selection ----------
  function clearSelection(){
    selectedNodeId = null;
    selectedLinkId = null;
    multi.clear();
    render();
  }
  function selectNode(id){
    selectedNodeId = id;
    selectedLinkId = null;
    render();
  }
  function selectLink(id){
    selectedLinkId = id;
    selectedNodeId = null;
    multi.clear();
    render();
  }
  function toggleMulti(id){
    if (multi.has(id)) multi.delete(id);
    else multi.add(id);
    selectedNodeId = id;
    selectedLinkId = null;
    render();
  }

  // ---------- edge connector ----------
  // —Ç–æ—á–∫–∞ –≤—ã—Ö–æ–¥–∞ —Å –∫—Ä–∞—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –∫ –¥—Ä—É–≥–æ–º—É —É–∑–ª—É
  function edgePoint(fromNode, toNode){
    const cx = fromNode.x + fromNode.w/2;
    const cy = fromNode.y + fromNode.h/2;
    const tx = toNode.x + toNode.w/2;
    const ty = toNode.y + toNode.h/2;

    let dx = tx - cx;
    let dy = ty - cy;

    if (dx === 0 && dy === 0) { dx = 1; dy = 0; }

    const hw = fromNode.w/2;
    const hh = fromNode.h/2;

    const adx = Math.abs(dx);
    const ady = Math.abs(dy);

    // –≤—ã–±–∏—Ä–∞–µ–º –º–∞—Å—à—Ç–∞–± —Ç–∞–∫, —á—Ç–æ–±—ã –ø–æ–ø–∞—Å—Ç—å –Ω–∞ –≥—Ä–∞–Ω–∏—Ü—É –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
    const sx = adx ? (hw / adx) : Infinity;
    const sy = ady ? (hh / ady) : Infinity;
    const t = Math.min(sx, sy);

    return { x: cx + dx * t, y: cy + dy * t };
  }

  // ---------- render ----------
  function el(name, attrs={}){
    const x = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) x.setAttribute(k, String(v));
    return x;
  }

  function render(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const gView = el("g", { transform: `translate(${state.view.x},${state.view.y}) scale(${state.view.k})` });
    svg.appendChild(gView);

    // links
    state.links.forEach(l => {
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) return;

      const p1 = edgePoint(a, b);
      const p2 = edgePoint(b, a);

      const dx = (p2.x - p1.x);
      const c1x = p1.x + dx * 0.33;
      const c2x = p1.x + dx * 0.66;

      const d = `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`;

      const path = el("path", {
        d,
        class: "link" + (l.id === selectedLinkId ? " selected" : ""),
        "data-link-id": l.id
      });
      path.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        selectLink(l.id);
      });
      gView.appendChild(path);
    });

    // nodes
    state.nodes.forEach(n => {
      const isSel = (n.id === selectedNodeId);
      const isMulti = multi.has(n.id);

      const gn = el("g", {
        class: "node" + (isSel ? " selected" : "") + (isMulti ? " multi" : ""),
        transform: `translate(${n.x},${n.y})`,
        "data-node-id": n.id
      });

      const rect = el("rect", {
        width: n.w,
        height: n.h,
        rx: 14,
        ry: 14,
        style: `fill:${n.style?.fill || "rgba(255,255,255,.07)"};stroke:${n.style?.stroke || "rgba(255,255,255,.18)"};stroke-width:1.2;`
      });
      gn.appendChild(rect);

      // HTML inside node (wrap + safe overflow)
      const fo = el("foreignObject", { x: 0, y: 0, width: n.w, height: n.h });
      const div = document.createElement("div");
      div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
      div.style.cssText = `
        width:${n.w}px; height:${n.h}px;
        display:flex; align-items:center; gap:10px;
        padding: 10px 12px;
        color: rgba(234,242,255,.96);
        font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        overflow:hidden;
        user-select:none;
      `;
      const icon = document.createElement("div");
      icon.style.cssText = `flex:0 0 auto; font-size:16px; opacity:.95;`;
      icon.textContent = n.icon || "";

      const text = document.createElement("div");
      text.style.cssText = `
        flex:1 1 auto;
        overflow:hidden;
        display:-webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        word-break: break-word;
        line-height: 1.15;
      `;
      text.textContent = n.text || "";

      div.appendChild(icon);
      div.appendChild(text);
      fo.appendChild(div);
      gn.appendChild(fo);

      // interactions
      gn.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        closeEditor(true);

        if (e.ctrlKey || e.metaKey){
          toggleMulti(n.id);
          svg.setPointerCapture(e.pointerId);
          return;
        }

        selectNode(n.id);

        const moveIds = (multi.size && multi.has(n.id)) ? [...multi] : [n.id];
        drag = {
          type: "node",
          sx: e.clientX, sy: e.clientY,
          base: moveIds.map(id => {
            const nn = getNode(id);
            return {id, x: nn.x, y: nn.y};
          })
        };
        svg.setPointerCapture(e.pointerId);
      });

      // dblclick on node => add child quickly + start rename
      gn.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        const childId = addChildFrom(n.id, true);
        startRename(childId);
      });

      gView.appendChild(gn);
    });

    wrap.style.cursor = isSpaceDown ? "grab" : "default";
  }

  // ---------- quick child ----------
  function addChildFrom(parentId, autoLink=true){
    const parent = getNode(parentId);
    if (!parent) return null;

    const paletteIndex = ((parent.childColorNext || 0) + 1) % PALETTE.length;
    parent.childColorNext = (parent.childColorNext || 0) + 1;

    const style = PALETTE[paletteIndex];

    const x = parent.x + parent.w + 120;
    const y = parent.y + (Math.random()*60 - 30);

    const childId = addNode(x, y, "–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è", "‚úÖ", style);
    if (autoLink) addLink(parentId, childId);
    return childId;
  }

  // ---------- editor (rename) ----------
  function closeEditor(saveIfAny){
    if (!editorEl) return;
    const input = editorEl.querySelector("input");
    const nodeId = editorEl.getAttribute("data-node-id");
    const n = getNode(nodeId);
    if (saveIfAny && n){
      const val = (input.value || "").trim();
      n.text = val || n.text || "–ò–¥–µ—è";
      const {w,h} = measureNode(n.text);
      n.w = w; n.h = h;
      save(); render();
    }
    editorEl.remove();
    editorEl = null;
  }

  function startRename(nodeId){
    const n = getNode(nodeId);
    if (!n) { showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª"); return; }

    closeEditor(false);

    const tl = worldToClient(n.x, n.y);
    const w = Math.max(220, n.w * state.view.k);
    const h = 86;

    const ed = document.createElement("div");
    ed.className = "editor";
    ed.setAttribute("data-node-id", n.id);
    ed.style.left = `${tl.x}px`;
    ed.style.top  = `${tl.y + n.h*state.view.k + 10}px`;
    ed.style.width = `${Math.min(w, wrap.clientWidth - 20)}px`;

    ed.innerHTML = `
      <input type="text" />
      <div class="help">Enter ‚Äî —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å ‚Ä¢ Esc ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å</div>
    `;
    wrap.appendChild(ed);
    editorEl = ed;

    const input = ed.querySelector("input");
    input.value = n.text || "";
    input.focus();
    input.select();

    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        closeEditor(true);
      }
      if (e.key === "Escape"){
        e.preventDefault();
        closeEditor(false);
      }
    });

    input.addEventListener("blur", () => {
      // blur = save (—á—Ç–æ–±—ã —É–¥–æ–±–Ω–æ –±—ã–ª–æ)
      closeEditor(true);
    });
  }

  // ---------- persistence ----------
  function save(){
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }catch(e){}
  }

  function load(){
    try{
      // migrate from v2/v1 if needed
      const v3 = localStorage.getItem(STORAGE_KEY);
      if (!v3){
        const v2 = localStorage.getItem(OLD_KEY_V2);
        const v1 = localStorage.getItem(OLD_KEY_V1);
        const src = v2 || v1;
        if (src){
          const old = JSON.parse(src);
          if (old && Array.isArray(old.nodes) && Array.isArray(old.links)){
            state.nodes = old.nodes.map(n => {
              const text = n.text || "–ò–¥–µ—è";
              const {w,h} = measureNode(text);
              return {
                id: n.id || uid(),
                x: Number(n.x)||0,
                y: Number(n.y)||0,
                w: n.w || w,
                h: n.h || h,
                text,
                icon: (typeof n.icon === "string") ? n.icon : "üí°",
                style: n.style ? n.style : {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
                childColorNext: n.childColorNext || 0
              };
            });
            state.links = old.links.map(l => ({id: l.id || uid(), a: l.a, b: l.b})).filter(l => l.a && l.b);
            state.view = old.view || {x:20,y:20,k:1};
            save();
          }
        }
      }

      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const obj = JSON.parse(raw);
      if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.links)) return false;

      state = obj;
      state.view ||= {x:20,y:20,k:1};

      state.nodes.forEach(n => {
        n.text ||= "–ò–¥–µ—è";
        const {w,h} = measureNode(n.text);
        n.w ||= w; n.h ||= h;
        n.icon = (typeof n.icon === "string") ? n.icon : "üí°";
        if (!n.style) n.style = {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke};
        n.childColorNext = n.childColorNext || 0;
      });

      return true;
    }catch(e){
      return false;
    }
  }

  function exportJSON(){
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "mindmap.json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  }

  function importJSON(file){
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.links)) throw new Error("bad");

        obj.view ||= {x:20,y:20,k:1};
        obj.nodes.forEach(n => {
          n.text ||= "–ò–¥–µ—è";
          const {w,h} = measureNode(n.text);
          n.w ||= w; n.h ||= h;
          n.icon = (typeof n.icon === "string") ? n.icon : "üí°";
          if (!n.style) n.style = {fill: PALETTE[0].fill, stroke: PALETTE[0].stroke};
          n.childColorNext = n.childColorNext || 0;
        });

        state = obj;
        selectedNodeId = null;
        selectedLinkId = null;
        multi.clear();
        closeEditor(false);

        save(); render();
        showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
      }catch(e){
        showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å JSON");
      }
    };
    fr.readAsText(file);
  }

  // ---------- delete ----------
  function deleteSelected(){
    closeEditor(false);

    if (multi.size){
      const ids = new Set(multi);
      state.links = state.links.filter(l => !ids.has(l.a) && !ids.has(l.b));
      state.nodes = state.nodes.filter(n => !ids.has(n.id));
      multi.clear();
      selectedNodeId = null;
      save(); render();
      showToast("–£–∑–ª—ã —É–¥–∞–ª–µ–Ω—ã");
      return;
    }

    if (selectedNodeId){
      const id = selectedNodeId;
      state.links = state.links.filter(l => l.a !== id && l.b !== id);
      state.nodes = state.nodes.filter(n => n.id !== id);
      selectedNodeId = null;
      save(); render();
      showToast("–£–∑–µ–ª —É–¥–∞–ª—ë–Ω");
      return;
    }

    if (selectedLinkId){
      state.links = state.links.filter(l => l.id !== selectedLinkId);
      selectedLinkId = null;
      save(); render();
      showToast("–°–≤—è–∑—å —É–¥–∞–ª–µ–Ω–∞");
      return;
    }

    showToast("–ù–µ—á–µ–≥–æ —É–¥–∞–ª—è—Ç—å");
  }

  // ---------- auto layout (simple) ----------
  function autoLayout(){
    const rootId = selectedNodeId || (state.nodes[0] && state.nodes[0].id);
    if (!rootId){ showToast("–ù–µ—Ç —É–∑–ª–æ–≤"); return; }

    const adj = new Map();
    for (const n of state.nodes) adj.set(n.id, []);
    for (const l of state.links){
      if (!adj.has(l.a) || !adj.has(l.b)) continue;
      adj.get(l.a).push(l.b);
      adj.get(l.b).push(l.a);
    }

    const parent = new Map();
    const children = new Map();
    for (const n of state.nodes) children.set(n.id, []);
    parent.set(rootId, null);

    const q = [rootId];
    const seen = new Set([rootId]);
    while(q.length){
      const v = q.shift();
      for (const u of (adj.get(v)||[])){
        if (seen.has(u)) continue;
        seen.add(u);
        parent.set(u, v);
        children.get(v).push(u);
        q.push(u);
      }
    }

    const r = svg.getBoundingClientRect();
    const center = clientToWorld(r.left + r.width/2, r.top + r.height/2);
    const ring = 220;

    function place(v, depth, a0, a1){
      const n = getNode(v);
      if (!n) return;

      const ang = (a0 + a1) / 2;
      const rad = depth * ring;

      if (depth === 0){
        n.x = center.x - n.w/2;
        n.y = center.y - n.h/2;
      } else {
        const x = center.x + Math.cos(ang) * rad;
        const y = center.y + Math.sin(ang) * rad;
        n.x = x - n.w/2;
        n.y = y - n.h/2;
      }

      const kids = children.get(v) || [];
      if (!kids.length) return;

      const span = (a1 - a0);
      const step = span / kids.length;

      kids.forEach((c, i) => {
        place(c, depth+1, a0 + step*i, a0 + step*(i+1));
      });
    }

    place(rootId, 0, -Math.PI + 0.2, Math.PI - 0.2);

    save(); render();
    showToast("–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –≥–æ—Ç–æ–≤–∞");
  }

  // ---------- pointer events ----------
  svg.addEventListener("pointerdown", (e) => {
    if (isSpaceDown){
      drag = { type:"pan", sx:e.clientX, sy:e.clientY, ox:state.view.x, oy:state.view.y };
      svg.setPointerCapture(e.pointerId);
      wrap.style.cursor = "grabbing";
      return;
    }
    closeEditor(true);

    const nodeId = findNodeFromEvent(e);
    const linkId = findLinkFromEvent(e);

    if (!nodeId && !linkId){
      clearSelection();
    }
  });

  svg.addEventListener("pointermove", (e) => {
    if (!drag) return;

    if (drag.type === "node"){
      const dx = (e.clientX - drag.sx) / state.view.k;
      const dy = (e.clientY - drag.sy) / state.view.k;
      for (const b of drag.base){
        const n = getNode(b.id);
        if (!n) continue;
        n.x = b.x + dx;
        n.y = b.y + dy;
      }
      render();
      return;
    }

    if (drag.type === "pan"){
      const dx = (e.clientX - drag.sx);
      const dy = (e.clientY - drag.sy);
      state.view.x = drag.ox + dx;
      state.view.y = drag.oy + dy;
      render();
      return;
    }
  });

  svg.addEventListener("pointerup", () => {
    if (drag){
      drag = null;
      save(); render();
      wrap.style.cursor = isSpaceDown ? "grab" : "default";
    }
  });

  // dblclick on empty => new node + rename
  svg.addEventListener("dblclick", (e) => {
    // –µ—Å–ª–∏ dblclick –ø–æ —É–∑–ª—É ‚Äî –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞ —É–∑–ª–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç–∏—Ç
    const p = clientToWorld(e.clientX, e.clientY);
    const id = addNode(p.x - 90, p.y - 28, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
    startRename(id);
  });

  // zoom
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;

    const before = clientToWorld(e.clientX, e.clientY);
    const nk = Math.max(0.25, Math.min(2.8, state.view.k * factor));

    const r = svg.getBoundingClientRect();
    const vx = e.clientX - r.left;
    const vy = e.clientY - r.top;

    state.view.k = nk;
    state.view.x = vx - before.x * nk;
    state.view.y = vy - before.y * nk;

    render(); save();
  }, {passive:false});

  // keys
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space"){
      isSpaceDown = true;
      wrap.style.cursor = "grab";
      e.preventDefault();
    }
    if (e.key === "Delete" || e.key === "Backspace"){
      deleteSelected();
      e.preventDefault();
    }
    if (e.key === "Enter"){
      if (selectedNodeId){
        startRename(selectedNodeId);
        e.preventDefault();
      }
    }
    if (e.key === "Escape"){
      closeEditor(false);
      multi.clear();
      selectedLinkId = null;
      render();
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "Space"){
      isSpaceDown = false;
      wrap.style.cursor = "default";
    }
  });

  // mobile: long press rename
  let pressTimer = null;
  svg.addEventListener("pointerdown", (e) => {
    const nodeId = findNodeFromEvent(e);
    if (!nodeId) return;
    clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      selectNode(nodeId);
      startRename(nodeId);
    }, 560);
  });
  svg.addEventListener("pointerup", () => clearTimeout(pressTimer));
  svg.addEventListener("pointercancel", () => clearTimeout(pressTimer));

  function findNodeFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-node-id");
      if (id) return id;
    }
    return null;
  }
  function findLinkFromEvent(e){
    const path = e.composedPath ? e.composedPath() : [];
    for (const el of path){
      if (!el || !el.getAttribute) continue;
      const id = el.getAttribute("data-link-id");
      if (id) return id;
    }
    return null;
  }

  // buttons
  document.getElementById("addRoot").addEventListener("click", () => {
    closeEditor(true);
    if (state.nodes.length === 0){
      addNode(240, 180, "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è", "üéØ", PALETTE[0]);
      showToast("–°–æ–∑–¥–∞–Ω —Ü–µ–Ω—Ç—Ä");
    } else {
      const r = svg.getBoundingClientRect();
      const p = clientToWorld(r.left + r.width/2, r.top + r.height/2);
      const id = addNode(p.x - 90, p.y - 28, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
      startRename(id);
    }
  });

  document.getElementById("addChild").addEventListener("click", () => {
    closeEditor(true);
    if (!selectedNodeId){ showToast("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —É–∑–µ–ª"); return; }
    const id = addChildFrom(selectedNodeId, true);
    startRename(id);
  });

  document.getElementById("autoLayout").addEventListener("click", () => {
    closeEditor(true);
    autoLayout();
  });

  document.getElementById("rename").addEventListener("click", () => {
    if (!selectedNodeId){ showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª"); return; }
    startRename(selectedNodeId);
  });

  document.getElementById("del").addEventListener("click", deleteSelected);

  document.getElementById("export").addEventListener("click", exportJSON);
  document.getElementById("importFile").addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) importJSON(f);
    e.target.value = "";
  });

  document.getElementById("resetView").addEventListener("click", () => {
    closeEditor(true);
    fitDefault();
    showToast("–í–∏–¥ —Å–±—Ä–æ—à–µ–Ω");
  });

  document.getElementById("clearAll").addEventListener("click", () => {
    closeEditor(false);
    if (!confirm("–£–¥–∞–ª–∏—Ç—å –≤—Å—ë?")) return;
    state.nodes = [];
    state.links = [];
    selectedNodeId = null;
    selectedLinkId = null;
    multi.clear();
    fitDefault();
    save(); render();
    showToast("–û—á–∏—â–µ–Ω–æ");
  });

  // init
  const ok = load();
  if (!ok){
    fitDefault();
    addNode(240, 180, "–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è", "üéØ", PALETTE[0]);
  }
  render();

})();
</script>
</body>
</html>
