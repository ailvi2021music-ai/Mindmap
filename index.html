<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>MindMap</title>
  <meta name="theme-color" content="#f3f7ff"/>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --text:#0b1324;
      --stroke:rgba(11,19,36,.12);
      --shadow: 0 18px 60px rgba(10,20,40,.14);
      --grid:rgba(10,20,40,.06);
      --glass: rgba(255,255,255,.72);
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      overflow:hidden;
      background:
        radial-gradient(1000px 700px at 20% 10%, rgba(89,195,255,.28), transparent 58%),
        radial-gradient(900px 650px at 85% 20%, rgba(255,92,122,.20), transparent 60%),
        radial-gradient(1000px 700px at 55% 95%, rgba(60,224,122,.22), transparent 60%),
        linear-gradient(180deg, #f7fbff, #eef4ff 55%, #f8fbff);
    }

    .app{ height:100%; display:flex; flex-direction:column; }

    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:100;
      background: var(--glass);
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }

    .btn{
      appearance:none;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.70);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.06);
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font: 600 14px/1 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      height: 38px;
    }
    .btn:hover{ border-color: rgba(89,195,255,.45); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.55); }

    .dd{ position:relative; min-width:240px; }
    .ddBtn{ width:100%; justify-content:space-between; font-weight:600; }
    .ddList{
      position:absolute; top: 44px; left:0; right:0;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(11,19,36,.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 8px;
      display:none;
      max-height: 320px;
      overflow:auto;
      backdrop-filter: blur(10px);
      z-index: 200;
    }
    .ddItem{
      width:100%;
      border: 1px solid rgba(11,19,36,.10);
      background: rgba(255,255,255,.72);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      margin: 6px 0;
      user-select:none;
      font-weight:600;
    }
    .ddItem:hover{ border-color: rgba(89,195,255,.45); }
    .ddMeta{ font-weight:600; font-size:12px; color: rgba(11,19,36,.55); }

    .menuWrap{ position:relative; }
    .drop{
      position:absolute; top: 44px; right: 0;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(11,19,36,.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 8px;
      display:none;
      min-width: 240px;
      backdrop-filter: blur(10px);
      z-index: 200;
    }
    .drop .item{
      width:100%;
      border: 1px solid rgba(11,19,36,.10);
      background: rgba(255,255,255,.72);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      display:flex;
      justify-content:flex-start;
      gap:10px;
      align-items:center;
      margin: 6px 0;
      user-select:none;
      font-weight:600;
    }
    .drop .item:hover{ border-color: rgba(89,195,255,.45); }
    input[type="file"]{ display:none; }

    .stageWrap{
      flex:1;
      position:relative;
      overflow:hidden;

      user-select:none;
      -webkit-user-select:none;
      -ms-user-select:none;
      -moz-user-select:none;
    }
    .stageWrap::before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 42px 42px, 7px 7px;
      opacity:.75;
      pointer-events:none;
      z-index:0;
    }

    #svg{
      position:absolute; inset:0;
      z-index:1;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(255,255,255,.78);
      border:1px solid rgba(11,19,36,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(11,19,36,.92);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(900px, calc(100% - 24px));
      z-index:110;
      font-weight:700;
      white-space:pre-wrap;
    }
    .toast.show{ opacity:1; }

    /* Inline editor */
    #editor{
      position:absolute;
      z-index: 300;
      display:none;
      border-radius: 14px;
      border: 2px solid rgba(89,195,255,.75);
      box-shadow: var(--shadow);
      padding: 12px 14px;
      font: 600 16px/1.25 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      resize:none;
      outline:none;
      background: rgba(255,255,255,.95);
      color: var(--text);

      /* Важно: чтобы выделение мышкой работало */
      user-select:text;
      -webkit-user-select:text;
    }

    /* HTML overlay button (⋯) + menu */
    .nodeBtn{
      position:absolute;
      z-index: 220;
      width:24px;
      height:24px;
      border-radius:999px;
      border:1px solid rgba(11,19,36,.18);
      background: rgba(255,255,255,.92);
      box-shadow: 0 10px 20px rgba(10,20,40,.14);
      display:none;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      padding:0;
    }
    .nodeBtnDots{
      width:3px;height:3px;border-radius:50%;
      background: rgba(11,19,36,.78);
      box-shadow: 0 -5px 0 rgba(11,19,36,.78), 0 5px 0 rgba(11,19,36,.78);
      transform: translateY(-.5px); /* визуально центр */
    }

    .nodeMenu{
      position:absolute;
      z-index: 221;
      display:none;
      gap:8px;
      align-items:center;
      padding:8px;
      border-radius: 14px;
      background: rgba(20,28,40,.92);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .nodeMenu .mBtn{
      width:34px; height:34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      user-select:none;
      font-weight:800;
      font-size:16px;
      line-height:1;
    }
    .nodeMenu .mBtn:hover{
      border-color: rgba(89,195,255,.35);
      background: rgba(255,255,255,.10);
    }
  </style>
</head>

<body>
<div class="app">
  <header>
    <div class="dd" id="projDD">
      <button class="btn ddBtn" id="projBtn">
        <span id="projBtnText">Майндмэп</span>
        <span style="opacity:.7">▾</span>
      </button>
      <div class="ddList" id="projList"></div>
    </div>

    <button class="btn primary" id="projNew">+ Новый</button>

    <div class="menuWrap">
      <button class="btn" id="downloadBtn">Скачать ▾</button>
      <div class="drop" id="downloadDrop">
        <div class="item" id="exportOneBtn">Экспорт карты</div>
        <label class="item" for="importOne">Импорт карты</label>
        <div class="item" id="exportAllBtn">Экспорт всех</div>
        <label class="item" for="importAll">Импорт всех</label>
      </div>
    </div>

    <input id="importOne" type="file" accept="application/json"/>
    <input id="importAll" type="file" accept="application/json"/>
  </header>

  <div class="stageWrap" id="wrap">
    <svg id="svg" xmlns="http://www.w3.org/2000/svg" aria-label="Mindmap canvas">
      <g id="links"></g>
      <g id="nodes"></g>
    </svg>

    <!-- HTML overlays -->
    <button class="nodeBtn" id="nodeBtn" title="Меню узла"><span class="nodeBtnDots"></span></button>
    <div class="nodeMenu" id="nodeMenu" role="menu" aria-label="Node menu">
      <div class="mBtn" data-act="child" title="Дочерняя идея">↳</div>
      <div class="mBtn" data-act="edit" title="Переименовать">✎</div>
      <div class="mBtn" data-act="collapse" title="Свернуть/развернуть">○</div>
      <div class="mBtn" data-act="delete" title="Удалить ветку">⌫</div>
      <div class="mBtn" data-act="close" title="Закрыть">×</div>
    </div>

    <textarea id="editor" rows="2"></textarea>
    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  const STORE_KEY = "mindmap_projects_v10_viewbox";

  const PALETTE = [
    {fill:"rgba(89,195,255,.20)", stroke:"rgba(33,140,210,.62)"},
    {fill:"rgba(255,92,122,.18)", stroke:"rgba(230,70,95,.64)"},
    {fill:"rgba(60,224,122,.18)", stroke:"rgba(30,170,85,.62)"},
    {fill:"rgba(255,209,102,.20)", stroke:"rgba(205,150,40,.64)"},
    {fill:"rgba(176,122,255,.18)", stroke:"rgba(135,90,210,.64)"},
    {fill:"rgba(255,255,255,.80)", stroke:"rgba(11,19,36,.18)"}
  ];

  const svg = document.getElementById("svg");
  const linksG = document.getElementById("links");
  const nodesG = document.getElementById("nodes");
  const wrap = document.getElementById("wrap");
  const toast = document.getElementById("toast");
  const editor = document.getElementById("editor");

  const nodeBtn = document.getElementById("nodeBtn");
  const nodeMenu = document.getElementById("nodeMenu");

  const projBtn = document.getElementById("projBtn");
  const projBtnText = document.getElementById("projBtnText");
  const projList = document.getElementById("projList");
  const projNew = document.getElementById("projNew");

  const downloadBtn = document.getElementById("downloadBtn");
  const downloadDrop = document.getElementById("downloadDrop");
  const exportOneBtn = document.getElementById("exportOneBtn");
  const exportAllBtn = document.getElementById("exportAllBtn");
  const importOne = document.getElementById("importOne");
  const importAll = document.getElementById("importAll");

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);
  const nowTs = () => Date.now();

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 2200);
  }

  // показываем ошибку вместо "белого экрана"
  window.addEventListener("error", (e) => showToast("Ошибка: " + (e.message || e.error || "unknown")));
  window.addEventListener("unhandledrejection", (e) => showToast("Ошибка: " + (e.reason?.message || e.reason || "promise rejection")));

  // ---------- SVG-safe helpers ----------
  function safeMatches(el, selector){
    if (!el) return false;
    const fn = el.matches || el.msMatchesSelector || el.webkitMatchesSelector;
    if (fn) return fn.call(el, selector);
    return false;
  }
  function safeClosest(el, selector){
    let cur = el;
    while(cur){
      if (cur.nodeType === 1 && safeMatches(cur, selector)) return cur;
      cur = cur.parentNode;
    }
    return null;
  }

  // ---------- Storage ----------
  function saveStore(){
    try{ localStorage.setItem(STORE_KEY, JSON.stringify(store)); }catch(e){}
  }
  function loadStore(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (obj && obj.projects && typeof obj.projects === "object") return obj;
    }catch(e){}
    return null;
  }

  // Камера теперь в WORLD-координатах: x,y = левый верх viewBox, k = zoom
  // (чем больше k — тем ближе)
  function createEmptyProject(name="Новый майндмэп"){
    const id = uid();
    const centerId = uid();
    const data = {
      cam:{x: 0, y: 0, k: 1},
      nodes: [{
        id:centerId,
        x: 360, y: 240,
        text:"Центральная идея",
        style:{...PALETTE[0]},
        parentId:null,
        collapsed:false,
        childColorNext:0,
        fmt:{bold:false, italic:false, align:"center"}
      }],
      links: []
    };
    const p = { id, name, createdAt: nowTs(), updatedAt: nowTs(), data };
    store.projects[id] = p;
    store.activeId = id;
    saveStore();
    return p;
  }

  let store = loadStore();
  if (!store || !store.projects || typeof store.projects !== "object"){
    store = { activeId:null, projects:{} };
  }
  if (!Object.keys(store.projects).length){
    createEmptyProject("Мой первый майндмэп");
  }
  if (!store.activeId || !store.projects[store.activeId]){
    store.activeId = Object.keys(store.projects)[0];
    saveStore();
  }

  let active = null;
  let map = null;

  let selectedId = null;
  let editingId = null;

  // drag state
  let drag = null;

  // overlay state
  let menuOpen = false;

  function commitMap(){
    if (!active || !map) return;
    active.updatedAt = nowTs();
    active.data = JSON.parse(JSON.stringify(map));
    saveStore();
  }
  function autosave(){
    clearTimeout(autosave._t);
    autosave._t = setTimeout(commitMap, 250);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }
  function safeName(s){ return (s||"mindmap").replace(/[^\w\d\-_.]+/g,"_"); }
  function downloadJson(obj, filename){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // ---------- Camera / viewBox ----------
  function stageSize(){
    const r = svg.getBoundingClientRect();
    return {w: r.width || 1, h: r.height || 1, left:r.left, top:r.top};
  }

  function applyViewBox(){
    const {w,h} = stageSize();
    const cam = map.cam;

    // ширина/высота viewBox уменьшаются при zoom-in
    const vw = w / cam.k;
    const vh = h / cam.k;

    svg.setAttribute("viewBox", `${cam.x} ${cam.y} ${vw} ${vh}`);
  }

  function clientToWorld(cx, cy){
    const r = svg.getBoundingClientRect();
    const cam = map.cam;
    return {
      x: cam.x + (cx - r.left) / cam.k,
      y: cam.y + (cy - r.top) / cam.k
    };
  }
  function worldToClient(wx, wy){
    const r = svg.getBoundingClientRect();
    const cam = map.cam;
    return {
      x: r.left + (wx - cam.x) * cam.k,
      y: r.top + (wy - cam.y) * cam.k
    };
  }

  // ---------- Graph helpers ----------
  function getNode(id){ return map.nodes.find(n => n.id === id); }
  function childrenOf(id){ return map.nodes.filter(n => n.parentId === id).map(n => n.id); }
  function isHiddenByCollapse(nodeId){
    let cur = getNode(nodeId);
    while(cur && cur.parentId){
      const p = getNode(cur.parentId);
      if (p && p.collapsed) return true;
      cur = p;
    }
    return false;
  }

  function clear(g){ while(g.firstChild) g.removeChild(g.firstChild); }

  function measureTextWidth(text, weight=600, size=16){
    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x", -9999);
    t.setAttribute("y", -9999);
    t.style.fontFamily = "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    t.style.fontWeight = String(weight);
    t.style.fontSize = size + "px";
    t.textContent = text || "";
    svg.appendChild(t);
    const w = t.getBBox().width;
    svg.removeChild(t);
    return w;
  }

  function nodeBox(n){
    const padX = 22;
    const minW = 170;
    const maxW = 520;
    const fontSize = 20;
    const weight = (n.fmt && n.fmt.bold) ? 700 : 600;
    const txt = (n.text || "").trim() || "Идея";
    const w = Math.max(minW, Math.min(maxW, Math.ceil(measureTextWidth(txt, weight, fontSize) + padX*2)));
    const h = 64;
    return {w,h, fontSize, weight};
  }

  function addLink(a,b){
    if (!a || !b || a===b) return;
    const exists = map.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    map.links.push({ id: uid(), a, b });
  }

  function addChildFrom(parentId, preferPoint=null){
    const p = getNode(parentId);
    if (!p) return null;

    const idx = ((p.childColorNext||0) + 1) % PALETTE.length;
    p.childColorNext = (p.childColorNext||0) + 1;
    const style = PALETTE[idx];

    // позиция: по умолчанию справа; если кликнули в точку — уводим ближе к ней
    let x = p.x + 260;
    let y = p.y + (Math.random()*80 - 40);
    if (preferPoint){
      // тянем в сторону клика, но ограничиваем
      const dx = Math.max(140, Math.min(360, preferPoint.x - p.x));
      const dy = Math.max(-220, Math.min(220, preferPoint.y - p.y));
      x = p.x + dx;
      y = p.y + dy;
    }

    const id = uid();
    map.nodes.push({
      id,
      x,
      y,
      text:"Дочерняя идея",
      style:{...style},
      parentId: parentId,
      collapsed:false,
      childColorNext:0,
      fmt:{bold:false, italic:false, align:"center"}
    });

    addLink(parentId, id);
    selectedId = id;
    menuOpen = false;
    autosave();
    renderAll();
    beginEdit(id, true);
    return id;
  }

  function deleteSubtree(id){
    const ids = new Set();
    const stack = [id];
    while(stack.length){
      const v = stack.pop();
      ids.add(v);
      for (const c of childrenOf(v)) stack.push(c);
    }
    map.nodes = map.nodes.filter(n => !ids.has(n.id));
    map.links = map.links.filter(l => !ids.has(l.a) && !ids.has(l.b));
    if (selectedId && ids.has(selectedId)) selectedId = null;
    menuOpen = false;
    autosave();
    renderAll();
  }

  function toggleCollapse(id){
    const n = getNode(id);
    if (!n) return;
    n.collapsed = !n.collapsed;
    autosave();
    renderAll();
  }

  function edgePoint(from, to){
    const b1 = nodeBox(from);
    const b2 = nodeBox(to);
    const cx = from.x + b1.w/2, cy = from.y + b1.h/2;
    const tx = to.x + b2.w/2, ty = to.y + b2.h/2;
    let dx = tx - cx, dy = ty - cy;
    if (dx === 0 && dy === 0) { dx = 1; dy = 0; }

    const hw = b1.w/2, hh = b1.h/2;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const sx = adx ? (hw / adx) : Infinity;
    const sy = ady ? (hh / ady) : Infinity;
    const t = Math.min(sx, sy);
    return { x: cx + dx*t, y: cy + dy*t };
  }

  // ---------- Render ----------
  function renderLinks(){
    clear(linksG);

    for (const l of map.links){
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) continue;
      if (isHiddenByCollapse(a.id) || isHiddenByCollapse(b.id)) continue;

      const p1 = edgePoint(a,b);
      const p2 = edgePoint(b,a);
      const dx = p2.x - p1.x;

      const c1x = p1.x + dx * 0.33;
      const c2x = p1.x + dx * 0.66;

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`);
      path.setAttribute("fill","none");
      path.setAttribute("stroke","rgba(30,90,150,.45)");
      path.setAttribute("stroke-width","3");
      path.setAttribute("stroke-linecap","round");
      // важно: stroke не "жирнеет" при зуме
      path.setAttribute("vector-effect","non-scaling-stroke");
      linksG.appendChild(path);
    }
  }

  function renderNodes(){
    clear(nodesG);

    for (const n of map.nodes){
      if (isHiddenByCollapse(n.id)) continue;

      const {w,h,fontSize,weight} = nodeBox(n);

      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("data-id", n.id);
      g.setAttribute("transform", `translate(${n.x} ${n.y})`);
      g.style.cursor = editingId ? "default" : "grab";

      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("width", w);
      rect.setAttribute("height", h);
      rect.setAttribute("rx", 18);
      rect.setAttribute("fill", n.style?.fill || "rgba(255,255,255,.8)");
      rect.setAttribute("stroke", n.style?.stroke || "rgba(11,19,36,.18)");
      rect.setAttribute("stroke-width", (selectedId===n.id) ? "3" : "2");
      rect.setAttribute("filter", "drop-shadow(0px 10px 16px rgba(10,20,40,.14))");
      rect.setAttribute("vector-effect","non-scaling-stroke");
      g.appendChild(rect);

      const text = document.createElementNS("http://www.w3.org/2000/svg","text");
      text.setAttribute("y", h/2 + 7);
      text.setAttribute("dominant-baseline","middle");
      text.style.fontFamily = "Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      text.style.fontSize = fontSize + "px";
      text.style.fontWeight = String(weight);
      text.style.fontStyle = (n.fmt && n.fmt.italic) ? "italic" : "normal";
      text.style.fill = "rgba(11,19,36,.90)";
      text.textContent = (n.text || "").trim() || "Идея";

      const align = (n.fmt && n.fmt.align) ? n.fmt.align : "center";
      if (align === "left"){
        text.setAttribute("text-anchor","start");
        text.setAttribute("x", 18);
      } else if (align === "right"){
        text.setAttribute("text-anchor","end");
        text.setAttribute("x", w - 18);
      } else {
        text.setAttribute("text-anchor","middle");
        text.setAttribute("x", w/2);
      }
      g.appendChild(text);

      // select
      g.addEventListener("pointerdown", (e) => {
        if (editingId) return;
        e.stopPropagation();
        selectedId = n.id;
        menuOpen = false;
        renderAll(); // обновит кнопку ⋯ позицию
      });

      // drag start
      g.addEventListener("pointerdown", (e) => {
        if (editingId) return;
        e.stopPropagation();
        startNodeDrag(e, n.id);
      });

      hookTapLogic(g, n.id);

      nodesG.appendChild(g);

      // collapse indicator (кружок — заполненный/пустой)
      const kids = childrenOf(n.id);
      if (kids.length){
        const dot = document.createElementNS("http://www.w3.org/2000/svg","g");
        dot.setAttribute("data-collapse-for", n.id);
        dot.setAttribute("transform", `translate(${n.x + w + 12} ${n.y + h/2 - 10})`);
        dot.style.cursor = "pointer";

        const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
        c.setAttribute("cx", 10);
        c.setAttribute("cy", 10);
        c.setAttribute("r", 10);
        c.setAttribute("fill","rgba(255,255,255,.92)");
        c.setAttribute("stroke", n.style?.stroke || "rgba(11,19,36,.22)");
        c.setAttribute("stroke-width","2");
        c.setAttribute("vector-effect","non-scaling-stroke");
        dot.appendChild(c);

        const inner = document.createElementNS("http://www.w3.org/2000/svg","circle");
        inner.setAttribute("cx", 10);
        inner.setAttribute("cy", 10);
        inner.setAttribute("r", 6);
        inner.setAttribute("fill", n.style?.stroke || "rgba(11,19,36,.22)");
        inner.setAttribute("opacity", n.collapsed ? "0.75" : "0.22");
        dot.appendChild(inner);

        dot.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          toggleCollapse(n.id);
        });

        nodesG.appendChild(dot);
      }
    }
  }

  // ---------- HTML overlay positioning ----------
  function hideOverlays(){
    nodeBtn.style.display = "none";
    nodeMenu.style.display = "none";
    menuOpen = false;
  }

  function positionNodeBtn(){
    if (!selectedId) { hideOverlays(); return; }
    const n = getNode(selectedId);
    if (!n || isHiddenByCollapse(selectedId)) { hideOverlays(); return; }

    const {w,h} = nodeBox(n);
    const p = worldToClient(n.x + w/2, n.y + h); // низ по центру
    const s = stageSize();

    // кнопка чуть ниже узла (буквально “полсантиметра”)
    const left = p.x - 12;
    const top  = p.y + 6;

    // clamp в пределах wrap
    const cl = Math.max(s.left + 8, Math.min(s.left + s.w - 32, left));
    const ct = Math.max(s.top + 8, Math.min(s.top + s.h - 32, top));

    nodeBtn.style.left = (cl - s.left) + "px";
    nodeBtn.style.top  = (ct - s.top) + "px";
    nodeBtn.style.display = "flex";
  }

  function positionNodeMenu(){
    if (!menuOpen || !selectedId) { nodeMenu.style.display="none"; return; }
    const n = getNode(selectedId);
    if (!n) { nodeMenu.style.display="none"; return; }

    const {w,h} = nodeBox(n);
    const s = stageSize();
    const p = worldToClient(n.x + w/2, n.y + h);

    nodeMenu.style.display = "flex";

    // меню всегда ниже кнопки ⋯
    const menuW = 8 + (5 * (34 + 8)); // приблизительно
    const left = (p.x - menuW/2);
    const top  = (p.y + 40);

    const cl = Math.max(s.left + 8, Math.min(s.left + s.w - menuW - 8, left));
    const ct = Math.max(s.top + 8, Math.min(s.top + s.h - 70, top));

    nodeMenu.style.left = (cl - s.left) + "px";
    nodeMenu.style.top  = (ct - s.top) + "px";
  }

  // ---------- Render all ----------
  function renderAll(){
    applyViewBox();
    renderLinks();
    renderNodes();
    positionNodeBtn();
    positionNodeMenu();
  }

  // ---------- Editor ----------
  function beginEdit(id, selectAll=false){
    const n = getNode(id);
    if (!n) return;

    editingId = id;
    menuOpen = false;
    renderAll();

    const {w,h,fontSize,weight} = nodeBox(n);
    const p = worldToClient(n.x, n.y);

    // редактор в пикселях (чётко, удобно)
    const cam = map.cam;
    const k = cam.k;

    editor.style.left = (p.x - stageSize().left) + "px";
    editor.style.top  = (p.y - stageSize().top) + "px";
    editor.style.width = Math.max(120, Math.round(w * k)) + "px";
    editor.style.height = Math.max(44, Math.round(h * k)) + "px";
    editor.style.fontSize = Math.max(14, Math.round(fontSize * k)) + "px";
    editor.style.fontWeight = String(weight);
    editor.style.fontStyle = (n.fmt && n.fmt.italic) ? "italic" : "normal";
    editor.style.textAlign = (n.fmt && n.fmt.align) ? n.fmt.align : "center";

    editor.value = (n.text || "").trim() || "Идея";
    editor.style.display = "block";
    editor.focus();

    // важно: нормальный селект
    if (selectAll) editor.select();

    const finish = (save) => {
      editor.onkeydown = null;
      editor.onblur = null;
      editor.style.display = "none";
      if (save){
        n.text = (editor.value || "").trim() || "Идея";
        autosave();
      }
      editingId = null;
      renderAll();
    };

    editor.onkeydown = (e) => {
      if (e.key === "Enter"){ e.preventDefault(); editor.blur(); }
      else if (e.key === "Escape"){ e.preventDefault(); finish(false); }
    };
    editor.onblur = () => finish(true);
  }

  // ---------- Tap logic (double/triple click) ----------
  const tap = { id:null, count:0, t:0, timer:null };
  const TAP_WINDOW = 420;

  function hookTapLogic(el, id){
    el.addEventListener("pointerup", (e) => {
      if (editingId) return;
      if (drag && drag.moved) return;

      const now = Date.now();
      const same = (tap.id === id) && (now - tap.t <= TAP_WINDOW);
      tap.id = id;
      tap.t = now;
      tap.count = same ? (tap.count + 1) : 1;

      if (tap.timer) clearTimeout(tap.timer);
      tap.timer = setTimeout(() => {
        if (tap.id !== id) return;
        if (tap.count === 2) addChildFrom(id);
        else if (tap.count >= 3) beginEdit(id, true);
        tap.id=null; tap.count=0; tap.timer=null;
      }, TAP_WINDOW + 30);
    });
  }

  // ---------- Dragging / pan ----------
  function startNodeDrag(e, nodeId){
    const n = getNode(nodeId);
    if (!n) return;
    drag = { kind:"node", id:nodeId, pid:e.pointerId, sx:e.clientX, sy:e.clientY, baseX:n.x, baseY:n.y, moved:false };
    svg.setPointerCapture(e.pointerId);
  }

  svg.addEventListener("pointermove", (e) => {
    if (!drag) return;

    if (drag.kind === "node"){
      const cam = map.cam;
      const dx = (e.clientX - drag.sx) / cam.k;
      const dy = (e.clientY - drag.sy) / cam.k;
      if (!drag.moved && Math.hypot(dx,dy) > 2) drag.moved = true;
      if (!drag.moved) return;

      const n = getNode(drag.id);
      if (!n) return;
      n.x = drag.baseX + dx;
      n.y = drag.baseY + dy;
      autosave();
      renderAll();
    }

    if (drag.kind === "pan"){
      const dx = (e.clientX - drag.sx);
      const dy = (e.clientY - drag.sy);
      if (!drag.moved && Math.hypot(dx,dy) > 4) drag.moved = true;
      if (!drag.moved) return;

      // пан = двигаем cam.x/cam.y в world
      const cam = map.cam;
      cam.x = drag.baseX - dx / cam.k;
      cam.y = drag.baseY - dy / cam.k;
      applyViewBox();
      positionNodeBtn();
      positionNodeMenu();
    }
  });

  svg.addEventListener("pointerup", (e) => {
    if (drag && drag.pid === e.pointerId){
      try{ svg.releasePointerCapture(e.pointerId); }catch(_){}
      drag = null;
    }
  });

  // пан на пустом
  svg.addEventListener("pointerdown", (e) => {
    if (editingId) return;

    const onNode = safeClosest(e.target, '[data-id]') || safeClosest(e.target, '[data-collapse-for]');
    if (!onNode){
      selectedId = null;
      hideOverlays();
      renderAll();

      const cam = map.cam;
      drag = { kind:"pan", pid:e.pointerId, sx:e.clientX, sy:e.clientY, baseX:cam.x, baseY:cam.y, moved:false };
      svg.setPointerCapture(e.pointerId);
    }
  });

  // Даблклик на пустом -> ДОЧЕРНЯЯ от выбранной (как ты подтвердил)
  svg.addEventListener("dblclick", (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (editingId) return;

    const onNode = safeClosest(e.target, '[data-id]') || safeClosest(e.target, '[data-collapse-for]');
    if (onNode) return;

    if (!selectedId) return; // строго по твоему правилу

    const p = clientToWorld(e.clientX, e.clientY);
    addChildFrom(selectedId, p);
  });

  // анти-яндекс “перевести/найти” на dblclick по холсту
  wrap.addEventListener("dblclick", (e) => e.preventDefault());

  // zoom (wheel) — через viewBox (без blur)
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    if (!map) return;

    const cam = map.cam;
    const step = 0.1;

    const dir = Math.sign(e.deltaY);
    let nk = cam.k + (dir > 0 ? -step : step);
    nk = Math.max(0.25, Math.min(3.5, nk));
    nk = Math.round(nk / step) * step;

    const before = clientToWorld(e.clientX, e.clientY);

    cam.k = nk;

    // чтобы точка под курсором оставалась под курсором
    const r = svg.getBoundingClientRect();
    const cx = e.clientX - r.left;
    const cy = e.clientY - r.top;
    cam.x = before.x - cx / cam.k;
    cam.y = before.y - cy / cam.k;

    applyViewBox();
    positionNodeBtn();
    positionNodeMenu();
    autosave();
  }, {passive:false});

  // ---------- HTML overlay interactions ----------
  nodeBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!selectedId) return;
    menuOpen = !menuOpen;
    positionNodeMenu();
  });

  nodeMenu.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
    const btn = e.target.closest(".mBtn");
    if (!btn) return;
    const act = btn.dataset.act;
    if (!act) return;

    if (act === "close"){
      menuOpen = false;
      positionNodeMenu();
      return;
    }

    if (!selectedId) return;
    if (act === "child") addChildFrom(selectedId);
    else if (act === "edit") beginEdit(selectedId, true);
    else if (act === "collapse") toggleCollapse(selectedId);
    else if (act === "delete") deleteSubtree(selectedId);

    // после действия закрываем меню
    menuOpen = false;
    positionNodeMenu();
  });

  document.addEventListener("pointerdown", (e) => {
    // клики вне меню/кнопки закрывают меню
    if (e.target.closest("#nodeMenu") || e.target.closest("#nodeBtn")) return;
    if (menuOpen){
      menuOpen = false;
      positionNodeMenu();
    }
  });

  // ---------- Projects UI ----------
  function rebuildProjectsUI(){
    const projects = Object.values(store.projects).sort((a,b)=> (b.updatedAt||0)-(a.updatedAt||0));
    projList.innerHTML = "";
    projects.forEach(p => {
      const item = document.createElement("div");
      item.className = "ddItem";
      item.innerHTML = `<span>${escapeHtml(p.name || "Без названия")}</span><span class="ddMeta">${new Date(p.updatedAt||p.createdAt||Date.now()).toLocaleDateString()}</span>`;
      item.onclick = () => { setActiveProject(p.id); projList.style.display="none"; };
      projList.appendChild(item);
    });

    const ap = store.projects[store.activeId];
    projBtnText.textContent = ap ? (ap.name || "Без названия") : "Майндмэп";
  }

  projBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault(); e.stopPropagation();
    projList.style.display = (projList.style.display === "block") ? "none" : "block";
    downloadDrop.style.display = "none";
  });

  document.addEventListener("pointerdown", (e) => {
    if (e.target.closest("#projDD")) return;
    projList.style.display = "none";
  });

  projNew.onclick = () => {
    const name = prompt("Название нового майндмэпа:", "Новый майндмэп");
    const p = createEmptyProject((name || "Новый майндмэп").trim());
    rebuildProjectsUI();
    setActiveProject(p.id);
    showToast("Создано");
  };

  function normalizeProject(p){
    // миграция v9->v10: view -> cam
    if (!p.data) p.data = { cam:{x:0,y:0,k:1}, nodes:[], links:[] };

    if (!p.data.cam){
      // если раньше была view {x,y,k} как pixel transform — поставим cam по-умному:
      // Принимаем, что "центр идеи" был где-то в районе 360/240. Это ок для старта.
      p.data.cam = { x: 0, y: 0, k: (p.data.view && p.data.view.k) ? p.data.view.k : 1 };
    }

    if (!Array.isArray(p.data.nodes) || !p.data.nodes.length){
      // восстановим центральную идею
      p.data.nodes = [{
        id: uid(),
        x: 360, y: 240,
        text:"Центральная идея",
        style:{...PALETTE[0]},
        parentId:null,
        collapsed:false,
        childColorNext:0,
        fmt:{bold:false, italic:false, align:"center"}
      }];
      p.data.links = [];
    }

    // гарантируем стиль/формат
    p.data.nodes.forEach((n,i) => {
      if (!n.style) n.style = {...PALETTE[i % PALETTE.length]};
      if (!n.fmt) n.fmt = {bold:false, italic:false, align:"center"};
      if (typeof n.collapsed !== "boolean") n.collapsed = false;
      if (typeof n.childColorNext !== "number") n.childColorNext = 0;
    });
  }

  function setActiveProject(id){
    const p = store.projects[id];
    if (!p) return;

    normalizeProject(p);

    store.activeId = id;
    active = p;
    map = JSON.parse(JSON.stringify(p.data));

    // подстроим камеру так, чтобы центральная идея была видна
    const cam = map.cam;
    if (!cam || typeof cam.k !== "number") map.cam = {x:0,y:0,k:1};

    selectedId = null;
    editingId = null;
    hideOverlays();

    saveStore();
    rebuildProjectsUI();

    // если есть центральный узел — выберем его для удобства
    const root = map.nodes.find(n => n.parentId == null) || map.nodes[0];
    if (root) selectedId = root.id;

    // выставим cam так, чтобы root оказался примерно в центре экрана
    const {w,h} = stageSize();
    const centerX = (root ? root.x : 360);
    const centerY = (root ? root.y : 240);
    map.cam.x = centerX - (w/(2*map.cam.k));
    map.cam.y = centerY - (h/(2*map.cam.k));

    autosave();
    renderAll();
  }

  // ---------- Download menu ----------
  function closeDownload(){ downloadDrop.style.display = "none"; }
  downloadBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault(); e.stopPropagation();
    downloadDrop.style.display = (downloadDrop.style.display === "block") ? "none" : "block";
    projList.style.display = "none";
  });

  document.addEventListener("pointerdown", (e) => {
    if (e.target.closest(".menuWrap")) return;
    closeDownload();
  });

  exportOneBtn.onclick = () => {
    commitMap();
    const payload = { kind:"mindmap_project", version:10, project: store.projects[store.activeId] };
    downloadJson(payload, safeName(active.name || "mindmap") + ".json");
    closeDownload();
    showToast("Экспортировано");
  };

  exportAllBtn.onclick = () => {
    commitMap();
    const payload = { kind:"mindmap_store", version:10, store };
    downloadJson(payload, "mindmaps_all.json");
    closeDownload();
    showToast("Экспорт всех готов");
  };

  importOne.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_project" || !obj.project) throw new Error("bad");
        const p = obj.project;
        if (!p.id) p.id = uid();
        p.createdAt ||= nowTs();
        p.updatedAt ||= nowTs();
        normalizeProject(p);
        store.projects[p.id] = p;
        store.activeId = p.id;
        saveStore();
        rebuildProjectsUI();
        setActiveProject(p.id);
        showToast("Импортировано");
      }catch(err){
        showToast("Ошибка импорта");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
    closeDownload();
  });

  importAll.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_store" || !obj.store) throw new Error("bad");
        const s = obj.store;
        if (!s.projects || typeof s.projects !== "object") throw new Error("bad");
        store = s;

        // нормализуем все проекты
        Object.values(store.projects).forEach(p => normalizeProject(p));

        if (!store.activeId || !store.projects[store.activeId]){
          store.activeId = Object.keys(store.projects)[0];
        }
        saveStore();
        rebuildProjectsUI();
        setActiveProject(store.activeId);
        showToast("Импорт выполнен");
      }catch(err){
        showToast("Ошибка импорта");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
    closeDownload();
  });

  // ---------- Init ----------
  rebuildProjectsUI();
  setActiveProject(store.activeId);

})();
</script>
</body>
</html>
