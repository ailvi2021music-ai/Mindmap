<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MindMap Pro Lite (Projects)</title>
  <meta name="theme-color" content="#f3f7ff" />
  <style>
    :root{
      --text:#0b1324;
      --muted:rgba(11,19,36,.60);
      --stroke:rgba(11,19,36,.12);
      --shadow: 0 18px 60px rgba(10,20,40,.14);
      --grid:rgba(10,20,40,.06);
      --radius:16px;
      --tool:rgba(20,28,40,.88);
      --toolText:rgba(255,255,255,.92);
      --toolStroke:rgba(255,255,255,.10);
      --glass: rgba(255,255,255,.72);
      --glass2: rgba(255,255,255,.82);
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%;
      margin:0;
      color:var(--text);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1000px 700px at 20% 10%, rgba(89,195,255,.28), transparent 58%),
        radial-gradient(900px 650px at 85% 20%, rgba(255,92,122,.20), transparent 60%),
        radial-gradient(1000px 700px at 55% 95%, rgba(60,224,122,.22), transparent 60%),
        linear-gradient(180deg, #f7fbff, #eef4ff 55%, #f8fbff);
      overflow:hidden;
    }

    .app{ height:100%; display:flex; flex-direction:column; }

    header{
      display:flex; gap:10px; align-items:center; padding:12px 14px;
      position:sticky; top:0; z-index:100;
      background: var(--glass);
      border-bottom:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      flex-wrap:wrap;
    }

    .brand{
      display:flex; flex-direction:column; gap:2px; margin-right:6px;
      min-width: 240px;
    }
    .brand b{ font-size:14px; letter-spacing:.2px; }
    .brand span{ color:var(--muted); font-size:12px; }

    .btn, select, input[type="text"]{
      appearance:none;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.70);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      box-shadow: 0 8px 22px rgba(0,0,0,.06);
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font: inherit;
      height: 38px;
    }
    select{ cursor:pointer; }
    .btn:hover, select:hover{ border-color: rgba(89,195,255,.45); }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(89,195,255,.55); }
    .btn.danger{ border-color: rgba(255,92,122,.55); }
    .sep{ width:1px; height:26px; background:var(--stroke); margin:0 2px; }

    .stageWrap{
      flex:1;
      position:relative;
      overflow:hidden;
    }
    .stageWrap::before{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid) 1px, transparent 1px);
      background-size: 42px 42px, 7px 7px;
      opacity:.75;
      pointer-events:none;
      z-index:0;
    }

    /* Left toolbar */
    .leftbar{
      position:absolute;
      left:14px; top:14px;
      z-index:80;
      background: var(--glass2);
      border:1px solid var(--stroke);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      backdrop-filter: blur(10px);
    }
    .toolbtn{
      width:44px; height:44px;
      border-radius:14px;
      border:1px solid rgba(11,19,36,.10);
      background: rgba(255,255,255,.78);
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
      position:relative;
    }
    .toolbtn:hover{ border-color: rgba(89,195,255,.45); }
    .toolbtn.active{
      border-color: rgba(89,195,255,.8);
      box-shadow: 0 0 0 3px rgba(89,195,255,.18) inset;
    }
    .toolbtn span{ font-size:18px; }
    .toolhint{
      position:absolute;
      left:58px;
      top:50%;
      transform: translateY(-50%);
      background: rgba(20,28,40,.88);
      color: rgba(255,255,255,.92);
      border:1px solid rgba(255,255,255,.10);
      padding:8px 10px;
      border-radius:12px;
      box-shadow: var(--shadow);
      white-space:nowrap;
      opacity:0;
      pointer-events:none;
      transition: .12s ease;
      z-index:120;
    }
    .toolbtn:hover .toolhint{ opacity:1; }

    /* Scene */
    #scene{
      position:absolute;
      inset:0;
      z-index:1;
      touch-action:none; /* we handle pan/zoom ourselves */
      user-select:none;
    }

    /* Transform wrapper (panned/zoomed world) */
    #world{
      position:absolute;
      left:0; top:0;
      transform-origin: 0 0;
      will-change: transform;
    }

    /* Links under nodes */
    #links{
      position:absolute;
      left:0; top:0;
      overflow:visible;
      pointer-events:none;
    }
    .link{
      stroke: rgba(30,90,150,.40);
      stroke-width: 2.2;
      fill: none;
    }

    /* Nodes layer */
    #nodes{
      position:absolute;
      left:0; top:0;
    }

    .node{
      position:absolute;
      border-radius: 16px;
      padding: 10px 12px;
      height: 58px;
      display:flex;
      align-items:center;
      gap:10px;
      box-shadow: 0 16px 26px rgba(10,20,40,.14);
      border: 1.2px solid rgba(11,19,36,.18);
      background: rgba(255,255,255,.80);
      cursor: grab;
      user-select:none;
      -webkit-user-select:none;
      min-width: 150px;
      max-width: 360px;
    }
    .node.selected{
      border-color: rgba(89,195,255,.95);
      box-shadow: 0 16px 26px rgba(10,20,40,.14), 0 0 0 3px rgba(89,195,255,.18) inset;
    }
    .node:active{ cursor: grabbing; }

    .node .icon{
      width:20px; height:20px;
      display:flex; align-items:center; justify-content:center;
      font-size:18px; line-height:1;
      flex:0 0 auto;
    }

    .node .text{
      flex:1 1 auto;
      line-height:1.15;
      overflow:hidden;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
      word-break: break-word;
      cursor: default;
    }

    .node.editing{
      cursor: text;
      user-select:text;
      -webkit-user-select:text;
    }
    .node.editing .text{
      outline: none;
      cursor: text;
      user-select:text;
      -webkit-user-select:text;
      -webkit-line-clamp: unset;
      display:block;
      overflow: visible;
      white-space: pre-wrap;
    }

    /* Collapse dot */
    .collapseDot{
      position:absolute;
      width: 22px; height: 22px;
      border-radius: 999px;
      background: rgba(255,255,255,.92);
      border:1px solid rgba(11,19,36,.16);
      box-shadow: 0 10px 18px rgba(10,20,40,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 16px;
      cursor: pointer;
      user-select:none;
      -webkit-user-select:none;
    }

    /* Context toolbar */
    .ctx{
      position:absolute;
      z-index:90;
      background: var(--tool);
      color: var(--toolText);
      border:1px solid var(--toolStroke);
      border-radius:14px;
      box-shadow: var(--shadow);
      display:flex;
      gap:6px;
      padding:8px;
      align-items:center;
      backdrop-filter: blur(10px);
      user-select:none;
      -webkit-user-select:none;
    }
    .ctx .cbtn{
      width:34px; height:34px;
      display:flex; align-items:center; justify-content:center;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      font-size:16px;
    }
    .ctx .cbtn:hover{ border-color: rgba(89,195,255,.50); }
    .ctx .csep{ width:1px; height:22px; background: rgba(255,255,255,.12); margin:0 2px; }
    .ctx .label{ font-size:12px; color: rgba(255,255,255,.70); padding:0 6px 0 2px; }

    .toast{
      position:absolute; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(255,255,255,.72);
      border:1px solid rgba(11,19,36,.14);
      padding:10px 12px; border-radius:12px;
      color:rgba(11,19,36,.86);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      opacity:0; pointer-events:none;
      transition: opacity .18s ease;
      max-width:min(720px, calc(100% - 24px));
      z-index:110;
    }
    .toast.show{ opacity:1; }

    input[type="file"]{ display:none; }

    @media (max-width: 720px){
      .brand span{ display:none; }
      .brand{ min-width: 140px; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <b>MindMap Pro Lite</b>
      <span>–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –ø–æ —É–∑–ª—É ‚Äî –¥–æ—á–µ—Ä–Ω–∏–π ‚Ä¢ –¢—Ä–æ–π–Ω–æ–π ‚Äî —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Ä¢ –ö–æ–ª–µ—Å–æ ‚Äî –∑—É–º ‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Ñ–æ–Ω–∞ ‚Äî –ø–∞–Ω</span>
    </div>

    <select id="projectSelect" title="–ú–∞–π–Ω–¥–º—ç–ø"></select>
    <button class="btn primary" id="projNew">+ –ù–æ–≤—ã–π</button>
    <button class="btn" id="projRename">–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å</button>
    <button class="btn" id="projDup">–î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å</button>
    <button class="btn danger" id="projDel">–£–¥–∞–ª–∏—Ç—å</button>

    <div class="sep"></div>

    <button class="btn" id="autoLayout">–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞</button>
    <button class="btn" id="resetView">–°–±—Ä–æ—Å –≤–∏–¥–∞</button>

    <div class="sep"></div>

    <button class="btn" id="exportOne">–≠–∫—Å–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã</button>
    <label class="btn" for="importOne">–ò–º–ø–æ—Ä—Ç –∫–∞—Ä—Ç—ã</label>
    <input id="importOne" type="file" accept="application/json" />

    <button class="btn" id="exportAll">–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö</button>
    <label class="btn" for="importAll">–ò–º–ø–æ—Ä—Ç –≤—Å–µ—Ö</label>
    <input id="importAll" type="file" accept="application/json" />
  </header>

  <div class="stageWrap" id="wrap">
    <div class="leftbar" id="leftbar">
      <div class="toolbtn active" data-tool="select"><span>üñ±Ô∏è</span><div class="toolhint">Select (V)</div></div>
      <div class="toolbtn" data-tool="hand"><span>‚úã</span><div class="toolhint">Hand/Pan (H)</div></div>
      <div class="toolbtn" data-tool="node"><span>‚ûï</span><div class="toolhint">Add node (N) ‚Äî –∫–ª–∏–∫ –ø–æ –ø–æ–ª—é</div></div>
      <div class="toolbtn" data-tool="center"><span>üéØ</span><div class="toolhint">Center on selection (C)</div></div>
    </div>

    <div class="ctx" id="ctx" style="display:none;">
      <div class="label">–£–∑–µ–ª</div>
      <div class="cbtn" id="ctxChild" title="–î–æ—á–µ—Ä–Ω–∏–π">‚Ü≥</div>
      <div class="cbtn" id="ctxSibling" title="–°–æ—Å–µ–¥–Ω–∏–π">‚Ü¶</div>
      <div class="cbtn" id="ctxRename" title="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å">‚úèÔ∏è</div>
      <div class="csep"></div>
      <div class="cbtn" id="ctxColor" title="–¶–≤–µ—Ç">üé®</div>
      <div class="cbtn" id="ctxIcon" title="–ò–∫–æ–Ω–∫–∞">üòä</div>
      <div class="cbtn" id="ctxCollapse" title="–°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å">‚§µÔ∏è</div>
      <div class="csep"></div>
      <div class="cbtn" id="ctxDelete" title="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</div>
      <div class="cbtn" id="ctxClose" title="–ó–∞–∫—Ä—ã—Ç—å">‚úñ</div>
    </div>

    <div id="scene">
      <div id="world">
        <svg id="links" xmlns="http://www.w3.org/2000/svg"></svg>
        <div id="nodes"></div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>
</div>

<script>
(() => {
  // ========= Storage model: multiple projects =========
  const STORE_KEY = "mindmap_projects_v1";

  const PALETTE = [
    {name:"Sky",    fill:"rgba(89,195,255,.20)", stroke:"rgba(33,140,210,.62)"},
    {name:"Rose",   fill:"rgba(255,92,122,.18)", stroke:"rgba(230,70,95,.64)"},
    {name:"Lime",   fill:"rgba(60,224,122,.18)", stroke:"rgba(30,170,85,.62)"},
    {name:"Amber",  fill:"rgba(255,209,102,.20)", stroke:"rgba(205,150,40,.64)"},
    {name:"Violet", fill:"rgba(176,122,255,.18)", stroke:"rgba(135,90,210,.64)"},
    {name:"Slate",  fill:"rgba(255,255,255,.80)", stroke:"rgba(11,19,36,.18)"}
  ];
  const ICONS = ["üí°","‚úÖ","üéØ","üìå","üß†","‚ö°","üß©","üî•","üìé","üîó","‚≠ê","üìù","üìö","üß™","üêû","üß≠"];

  const wrap = document.getElementById("wrap");
  const scene = document.getElementById("scene");
  const world = document.getElementById("world");
  const linksSvg = document.getElementById("links");
  const nodesLayer = document.getElementById("nodes");
  const toast = document.getElementById("toast");
  const ctx = document.getElementById("ctx");

  const projectSelect = document.getElementById("projectSelect");
  const importOne = document.getElementById("importOne");
  const importAll = document.getElementById("importAll");

  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=> toast.classList.remove("show"), 1400);
  }

  function nowTs(){ return Date.now(); }

  // ====== Data structures ======
  // store: { activeId, projects: { [id]: {id, name, createdAt, updatedAt, data:{nodes,links,view}} } }
  // map data: nodes: {id,x,y,w,h,text,icon,style,childColorNext,parentId,collapsed}
  let store = null;
  let active = null; // active project object
  let map = null;    // active.data

  let tool = "select";
  let selectedId = null;
  let editingId = null;

  const DRAG_THRESHOLD = 6;
  let drag = null; // {kind:'node'|'pan', pointerId, sx,sy, moved, baseX,baseY, startViewX,startViewY}
  const pointers = new Map();
  let pinch = null;

  // Tap logic (stable)
  const tap = { id:null, count:0, t:0, timer:null };
  const TAP_WINDOW = 420;

  const measureCanvas = document.createElement("canvas");
  const mctx = measureCanvas.getContext("2d");
  const FONT = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";

  function measureNode(text){
    mctx.font = FONT;
    const t = (text || "").trim() || "–ò–¥–µ—è";
    const raw = mctx.measureText(t).width;
    const minW = 150;
    const maxW = 360;
    const w = Math.max(minW, Math.min(maxW, Math.ceil(raw + 72)));
    const h = 58;
    return {w,h};
  }

  function saveStore(){
    try{ localStorage.setItem(STORE_KEY, JSON.stringify(store)); }catch(e){}
  }

  function loadStore(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (raw){
        const obj = JSON.parse(raw);
        if (obj && obj.projects && typeof obj.projects === "object"){
          return obj;
        }
      }
    }catch(e){}
    return null;
  }

  function normalizeMapData(data){
    data.view ||= {x:24,y:24,k:1};
    data.nodes ||= [];
    data.links ||= [];
    data.nodes.forEach(n => {
      n.text ||= "–ò–¥–µ—è";
      n.icon = (typeof n.icon === "string") ? n.icon : "üí°";
      n.style ||= { fill: PALETTE[0].fill, stroke: PALETTE[0].stroke };
      n.childColorNext ||= 0;
      n.parentId = n.parentId || null;
      n.collapsed = !!n.collapsed;
      const m = measureNode(n.text);
      n.w = m.w; n.h = m.h;
    });
    data.links = data.links.filter(l => l && l.a && l.b && l.a !== l.b);
    return data;
  }

  function createEmptyProject(name="–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø"){
    const id = uid();
    const data = normalizeMapData({
      nodes: [],
      links: [],
      view: {x:24,y:24,k:1}
    });

    // Create a center node by default
    const centerId = uid();
    const m = measureNode("–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è");
    data.nodes.push({
      id:centerId,
      x:260, y:180,
      w:m.w, h:m.h,
      text:"–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∏–¥–µ—è",
      icon:"üéØ",
      style:{fill: PALETTE[0].fill, stroke: PALETTE[0].stroke},
      childColorNext: 0,
      parentId: null,
      collapsed: false
    });

    const p = { id, name, createdAt: nowTs(), updatedAt: nowTs(), data };
    store.projects[id] = p;
    store.activeId = id;
    saveStore();
    return p;
  }

  function setActiveProject(id){
    const p = store.projects[id];
    if (!p) return;
    store.activeId = id;
    active = p;
    map = normalizeMapData(JSON.parse(JSON.stringify(p.data))); // work copy
    selectedId = null;
    editingId = null;
    saveStore();
    rebuildProjectSelect();
    renderAll();
  }

  function commitMap(){
    if (!active) return;
    active.updatedAt = nowTs();
    active.data = JSON.parse(JSON.stringify(map));
    saveStore();
  }

  // Debounced autosave
  function autosave(){
    clearTimeout(autosave._t);
    autosave._t = setTimeout(() => commitMap(), 250);
  }

  // ====== Init store/projects ======
  function init(){
    store = loadStore();
    if (!store){
      store = { activeId: null, projects: {} };
      createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    } else {
      // If empty, create one
      if (!store.projects || Object.keys(store.projects).length === 0){
        store.projects = {};
        createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
      }
      // Ensure activeId exists
      if (!store.activeId || !store.projects[store.activeId]){
        store.activeId = Object.keys(store.projects)[0];
      }
    }
    saveStore();
    rebuildProjectSelect();
    setActiveProject(store.activeId);
  }

  function rebuildProjectSelect(){
    projectSelect.innerHTML = "";
    const ids = Object.keys(store.projects)
      .map(id => store.projects[id])
      .sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0))
      .map(p => p.id);

    for (const id of ids){
      const p = store.projects[id];
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name || "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è";
      if (id === store.activeId) opt.selected = true;
      projectSelect.appendChild(opt);
    }
  }

  // ====== Map helpers ======
  function getNode(id){ return map.nodes.find(n => n.id === id); }
  function childrenOf(id){ return map.nodes.filter(n => n.parentId === id).map(n => n.id); }

  function isHiddenByCollapse(nodeId){
    let cur = getNode(nodeId);
    while(cur && cur.parentId){
      const p = getNode(cur.parentId);
      if (p && p.collapsed) return true;
      cur = p;
    }
    return false;
  }

  function addLink(a,b){
    if (!a || !b || a===b) return;
    const exists = map.links.some(l => (l.a===a && l.b===b) || (l.a===b && l.b===a));
    if (exists) return;
    map.links.push({ id: uid(), a, b });
  }

  function addNodeAt(x,y, text="–ù–æ–≤–∞—è –∏–¥–µ—è", icon="üí°", style=PALETTE[0]){
    const m = measureNode(text);
    const id = uid();
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text, icon,
      style: {fill: style.fill, stroke: style.stroke},
      childColorNext: 0,
      parentId: null,
      collapsed: false
    });
    selectedId = id;
    autosave();
    renderAll();
    return id;
  }

  function addChildFrom(parentId){
    const parent = getNode(parentId);
    if (!parent) return null;

    const idx = ((parent.childColorNext||0) + 1) % PALETTE.length;
    parent.childColorNext = (parent.childColorNext||0) + 1;
    const style = PALETTE[idx];

    const x = parent.x + parent.w + 140;
    const y = parent.y + (Math.random()*70 - 35);

    const id = uid();
    const m = measureNode("–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è");
    map.nodes.push({
      id,
      x, y, w:m.w, h:m.h,
      text:"–î–æ—á–µ—Ä–Ω—è—è –∏–¥–µ—è",
      icon:"‚úÖ",
      style:{fill: style.fill, stroke: style.stroke},
      childColorNext: 0,
      parentId: parentId,
      collapsed:false
    });
    addLink(parentId, id);

    selectedId = id;
    autosave();
    renderAll();
    return id;
  }

  function addSiblingFrom(nodeId){
    const n = getNode(nodeId);
    if (!n) return null;
    const parentId = n.parentId || null;

    const x = n.x;
    const y = n.y + n.h + 18;

    const id = uid();
    const m = measureNode("–ù–æ–≤–∞—è –∏–¥–µ—è");
    map.nodes.push({
      id, x, y, w:m.w, h:m.h,
      text:"–ù–æ–≤–∞—è –∏–¥–µ—è",
      icon: n.icon || "üí°",
      style: n.style ? {fill:n.style.fill, stroke:n.style.stroke} : {fill:PALETTE[0].fill, stroke:PALETTE[0].stroke},
      childColorNext: 0,
      parentId,
      collapsed:false
    });
    if (parentId) addLink(parentId, id);

    selectedId = id;
    autosave();
    renderAll();
    return id;
  }

  function deleteSubtree(id){
    const ids = new Set();
    const stack = [id];
    while(stack.length){
      const v = stack.pop();
      ids.add(v);
      for (const c of childrenOf(v)) stack.push(c);
    }
    map.nodes = map.nodes.filter(n => !ids.has(n.id));
    map.links = map.links.filter(l => !ids.has(l.a) && !ids.has(l.b));
    if (selectedId && ids.has(selectedId)) selectedId = null;
    autosave();
    renderAll();
  }

  function toggleCollapse(id){
    const n = getNode(id);
    if (!n) return;
    n.collapsed = !n.collapsed;
    autosave();
    renderAll();
  }

  // ====== View transform ======
  function applyTransform(){
    const v = map.view;
    world.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.k})`;
  }

  function clientToWorld(cx, cy){
    const r = scene.getBoundingClientRect();
    const v = map.view;
    return {
      x: (cx - r.left - v.x) / v.k,
      y: (cy - r.top  - v.y) / v.k
    };
  }

  function worldToClient(wx, wy){
    const r = scene.getBoundingClientRect();
    const v = map.view;
    return {
      x: r.left + v.x + wx * v.k,
      y: r.top  + v.y + wy * v.k
    };
  }

  // ====== Links drawing ======
  function edgePoint(fromNode, toNode){
    const cx = fromNode.x + fromNode.w/2;
    const cy = fromNode.y + fromNode.h/2;
    const tx = toNode.x + toNode.w/2;
    const ty = toNode.y + toNode.h/2;
    let dx = tx - cx, dy = ty - cy;
    if (dx === 0 && dy === 0) { dx = 1; dy = 0; }

    const hw = fromNode.w/2, hh = fromNode.h/2;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const sx = adx ? (hw / adx) : Infinity;
    const sy = ady ? (hh / ady) : Infinity;
    const t = Math.min(sx, sy);
    return { x: cx + dx * t, y: cy + dy * t };
  }

  function drawLinks(){
    // set big enough svg size (world coords)
    // We'll keep it large so it covers typical map; dynamic expand:
    const maxX = Math.max(2000, ...map.nodes.map(n => n.x + n.w + 300));
    const maxY = Math.max(1400, ...map.nodes.map(n => n.y + n.h + 300));
    linksSvg.setAttribute("width", maxX);
    linksSvg.setAttribute("height", maxY);

    linksSvg.innerHTML = "";
    for (const l of map.links){
      const a = getNode(l.a), b = getNode(l.b);
      if (!a || !b) continue;
      if (isHiddenByCollapse(a.id) || isHiddenByCollapse(b.id)) continue;

      const p1 = edgePoint(a, b);
      const p2 = edgePoint(b, a);
      const dx = p2.x - p1.x;
      const c1x = p1.x + dx * 0.33;
      const c2x = p1.x + dx * 0.66;
      const d = `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`;

      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute("d", d);
      path.setAttribute("class","link");
      linksSvg.appendChild(path);
    }
  }

  // ====== Nodes rendering ======
  function renderNodes(){
    nodesLayer.innerHTML = "";

    for (const n of map.nodes){
      if (isHiddenByCollapse(n.id)) continue;

      const div = document.createElement("div");
      div.className = "node" + (n.id === selectedId ? " selected" : "");
      div.style.left = n.x + "px";
      div.style.top  = n.y + "px";
      div.style.width = n.w + "px";
      div.style.height = n.h + "px";
      div.style.background = n.style?.fill || "rgba(255,255,255,.80)";
      div.style.borderColor = n.style?.stroke || "rgba(11,19,36,.18)";
      div.setAttribute("data-id", n.id);

      const icon = document.createElement("div");
      icon.className = "icon";
      icon.textContent = n.icon || "";

      const text = document.createElement("div");
      text.className = "text";
      text.textContent = n.text || "";

      div.appendChild(icon);
      div.appendChild(text);

      // pointerdown for selection + drag start
      div.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (editingId) return;

        selectedId = n.id;
        renderSelectionOnly();
        positionCtx();

        // start node drag
        drag = {
          kind: "node",
          pointerId: e.pointerId,
          sx: e.clientX, sy: e.clientY,
          moved: false,
          baseX: n.x, baseY: n.y
        };
        div.setPointerCapture(e.pointerId);
      });

      // Tap counting on pointerup of the same element
      div.addEventListener("pointerup", (e) => {
        e.stopPropagation();
        if (editingId) return;

        // if drag moved, ignore as click
        if (drag && drag.kind === "node" && drag.pointerId === e.pointerId && drag.moved) return;

        const now = Date.now();
        const same = (tap.id === n.id) && (now - tap.t <= TAP_WINDOW);

        tap.id = n.id;
        tap.t = now;
        tap.count = same ? (tap.count + 1) : 1;

        if (tap.timer) clearTimeout(tap.timer);
        tap.timer = setTimeout(() => {
          if (tap.id !== n.id) return;

          if (tap.count === 2){
            addChildFrom(n.id);
          } else if (tap.count >= 3){
            beginEdit(n.id);
          }
          tap.id = null;
          tap.count = 0;
          tap.timer = null;
        }, TAP_WINDOW + 30);
      });

      nodesLayer.appendChild(div);

      // collapse dot (if has children)
      const kids = childrenOf(n.id);
      if (kids.length){
        const dot = document.createElement("div");
        dot.className = "collapseDot";
        dot.style.left = (n.x + n.w + 10) + "px";
        dot.style.top  = (n.y + n.h/2 - 11) + "px";
        dot.textContent = n.collapsed ? "+" : "‚Äì";
        dot.title = n.collapsed ? "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å" : "–°–≤–µ—Ä–Ω—É—Ç—å";

        dot.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleCollapse(n.id);
        });

        nodesLayer.appendChild(dot);
      }
    }
  }

  function renderSelectionOnly(){
    // don‚Äôt rebuild everything: only selected class
    [...nodesLayer.querySelectorAll(".node")].forEach(el => {
      el.classList.toggle("selected", el.getAttribute("data-id") === selectedId);
    });
  }

  function renderAll(){
    applyTransform();
    drawLinks();
    renderNodes();
    positionCtx();
  }

  // ====== Context toolbar ======
  function positionCtx(){
    if (!selectedId) { ctx.style.display = "none"; return; }
    const nodeEl = nodesLayer.querySelector(`.node[data-id="${CSS.escape(selectedId)}"]`);
    const n = getNode(selectedId);
    if (!nodeEl || !n || isHiddenByCollapse(selectedId)) { ctx.style.display = "none"; return; }

    const rect = nodeEl.getBoundingClientRect();
    // Put it close: 6px below
    const left = rect.left + rect.width/2 - 180;
    const top  = rect.bottom + 6;

    ctx.style.display = "flex";
    ctx.style.left = Math.max(12, Math.min(window.innerWidth - 380, left)) + "px";
    ctx.style.top  = Math.max(76, Math.min(window.innerHeight - 60, top)) + "px";

    // collapse icon dim if no children
    const hasKids = childrenOf(selectedId).length > 0;
    document.getElementById("ctxCollapse").style.opacity = hasKids ? "1" : ".45";
  }

  document.getElementById("ctxChild").onclick = () => { if (selectedId) addChildFrom(selectedId); };
  document.getElementById("ctxSibling").onclick = () => { if (selectedId) addSiblingFrom(selectedId); };
  document.getElementById("ctxRename").onclick = () => { if (selectedId) beginEdit(selectedId); };
  document.getElementById("ctxColor").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    const i = PALETTE.findIndex(p => p.fill === n.style.fill && p.stroke === n.style.stroke);
    const next = PALETTE[(Math.max(0,i)+1) % PALETTE.length];
    n.style = {fill: next.fill, stroke: next.stroke};
    autosave(); renderAll();
  };
  document.getElementById("ctxIcon").onclick = () => {
    const n = getNode(selectedId); if (!n) return;
    const i = ICONS.indexOf(n.icon);
    n.icon = ICONS[(i+1+ICONS.length) % ICONS.length];
    autosave(); renderAll();
  };
  document.getElementById("ctxCollapse").onclick = () => { if (selectedId) toggleCollapse(selectedId); };
  document.getElementById("ctxDelete").onclick = () => { if (selectedId) deleteSubtree(selectedId); };
  document.getElementById("ctxClose").onclick = () => { selectedId = null; renderSelectionOnly(); positionCtx(); };

  // ====== Inline edit ======
  function beginEdit(id){
    if (editingId) return;
    const nodeEl = nodesLayer.querySelector(`.node[data-id="${CSS.escape(id)}"]`);
    const n = getNode(id);
    if (!nodeEl || !n) return;

    editingId = id;
    nodeEl.classList.add("editing");

    const textEl = nodeEl.querySelector(".text");
    textEl.contentEditable = "true";
    textEl.textContent = n.text || "";
    textEl.focus();

    // caret to end
    const range = document.createRange();
    range.selectNodeContents(textEl);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    const finish = (saveChanges) => {
      textEl.removeEventListener("keydown", onKey);
      textEl.removeEventListener("blur", onBlur);

      if (saveChanges){
        const val = (textEl.textContent || "").trim();
        n.text = val || "–ò–¥–µ—è";
        const m = measureNode(n.text);
        n.w = m.w; n.h = m.h;
      } else {
        textEl.textContent = n.text || "–ò–¥–µ—è";
      }

      textEl.contentEditable = "false";
      nodeEl.classList.remove("editing");
      editingId = null;

      autosave();
      renderAll();
    };

    const onKey = (e) => {
      if (e.key === "Enter"){ e.preventDefault(); textEl.blur(); }
      if (e.key === "Escape"){ e.preventDefault(); finish(false); }
      e.stopPropagation();
    };
    const onBlur = () => finish(true);

    textEl.addEventListener("keydown", onKey);
    textEl.addEventListener("blur", onBlur);
  }

  // ====== Pan / Zoom / Drag ======
  scene.addEventListener("pointerdown", (e) => {
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    // if pointerdown on empty space and tool is node -> create node
    const isOnNode = !!e.target.closest(".node") || !!e.target.closest(".collapseDot") || e.target.closest(".ctx");
    if (!isOnNode){
      if (tool === "node"){
        const p = clientToWorld(e.clientX, e.clientY);
        addNodeAt(p.x - 90, p.y - 30, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
        return;
      }
      // background selection clear
      selectedId = null;
      positionCtx();
      renderSelectionOnly();

      // start pan
      drag = {
        kind:"pan",
        pointerId:e.pointerId,
        sx:e.clientX, sy:e.clientY,
        moved:false,
        startViewX: map.view.x,
        startViewY: map.view.y
      };
      scene.setPointerCapture(e.pointerId);
    }

    // pinch start
    if (pointers.size === 2){
      const pts = [...pointers.values()];
      pinch = {
        dist0: Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y),
        k0: map.view.k
      };
    }
  });

  scene.addEventListener("pointermove", (e) => {
    if (pointers.has(e.pointerId)) pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    // pinch zoom
    if (pointers.size === 2 && pinch){
      const pts = [...pointers.values()];
      const dist = Math.hypot(pts[1].x-pts[0].x, pts[1].y-pts[0].y);
      const scale = dist / Math.max(1, pinch.dist0);
      const nk = Math.max(0.25, Math.min(3.2, pinch.k0 * scale));

      const mid = {x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2};
      const before = clientToWorld(mid.x, mid.y);

      map.view.k = nk;
      const r = scene.getBoundingClientRect();
      const vx = mid.x - r.left;
      const vy = mid.y - r.top;
      map.view.x = vx - before.x * nk;
      map.view.y = vy - before.y * nk;

      applyTransform();
      positionCtx();
      return;
    }

    if (!drag || drag.pointerId !== e.pointerId) return;

    const dx = e.clientX - drag.sx;
    const dy = e.clientY - drag.sy;
    const dist = Math.hypot(dx, dy);
    if (!drag.moved && dist > DRAG_THRESHOLD) drag.moved = true;
    if (!drag.moved) return;

    if (drag.kind === "pan"){
      map.view.x = drag.startViewX + dx;
      map.view.y = drag.startViewY + dy;
      applyTransform();
      positionCtx();
      autosave();
      return;
    }

    if (drag.kind === "node"){
      // node dragging is handled on node element via pointer capture, but
      // keep safe if it reaches here
    }
  });

  scene.addEventListener("pointerup", (e) => {
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinch = null;

    // release pan drag
    if (drag && drag.pointerId === e.pointerId && drag.kind === "pan"){
      drag = null;
    }
  });

  // Node drag move happens on captured node element via pointermove on scene is not reliable;
  // We'll attach global listener to move selected node while drag.kind === 'node'
  window.addEventListener("pointermove", (e) => {
    if (!drag || drag.kind !== "node" || drag.pointerId !== e.pointerId) return;
    const n = getNode(selectedId);
    if (!n) return;

    const dx = e.clientX - drag.sx;
    const dy = e.clientY - drag.sy;
    const dist = Math.hypot(dx, dy);
    if (!drag.moved && dist > DRAG_THRESHOLD) drag.moved = true;

    if (!drag.moved) return;

    n.x = drag.baseX + dx / map.view.k;
    n.y = drag.baseY + dy / map.view.k;

    // update only positions fast
    const nodeEl = nodesLayer.querySelector(`.node[data-id="${CSS.escape(n.id)}"]`);
    if (nodeEl){
      nodeEl.style.left = n.x + "px";
      nodeEl.style.top  = n.y + "px";
    }
    // collapse dot (if exists) will be rebuilt on full render; quick reposition now:
    const dot = nodesLayer.querySelector(`.collapseDot[data-dot-for="${CSS.escape(n.id)}"]`);
    if (dot){
      dot.style.left = (n.x + n.w + 10) + "px";
      dot.style.top  = (n.y + n.h/2 - 11) + "px";
    }

    drawLinks();
    positionCtx();
    autosave();
  }, {passive:false});

  window.addEventListener("pointerup", (e) => {
    if (drag && drag.pointerId === e.pointerId && drag.kind === "node"){
      drag = null;
    }
  });

  // Wheel zoom
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 0.92 : 1.08;

    const before = clientToWorld(e.clientX, e.clientY);
    const nk = Math.max(0.25, Math.min(3.2, map.view.k * factor));

    const r = scene.getBoundingClientRect();
    const vx = e.clientX - r.left;
    const vy = e.clientY - r.top;

    map.view.k = nk;
    map.view.x = vx - before.x * nk;
    map.view.y = vy - before.y * nk;

    applyTransform();
    positionCtx();
    autosave();
  }, {passive:false});

  // Dblclick empty space => new node
  scene.addEventListener("dblclick", (e) => {
    if (e.target.closest(".node") || e.target.closest(".collapseDot") || e.target.closest(".ctx")) return;
    const p = clientToWorld(e.clientX, e.clientY);
    addNodeAt(p.x - 90, p.y - 30, "–ù–æ–≤–∞—è –∏–¥–µ—è", "üí°", PALETTE[0]);
  });

  // ====== Toolbar/tool selection ======
  function setTool(t){
    tool = t;
    document.querySelectorAll(".toolbtn").forEach(b => b.classList.toggle("active", b.dataset.tool === t));
    if (t === "center") centerOnSelection();
  }
  document.getElementById("leftbar").addEventListener("click", (e) => {
    const btn = e.target.closest(".toolbtn");
    if (!btn) return;
    setTool(btn.dataset.tool);
  });

  function centerOnSelection(){
    if (!selectedId){ showToast("–í—ã–±–µ—Ä–∏ —É–∑–µ–ª"); setTool("select"); return; }
    const n = getNode(selectedId); if (!n) return;
    const r = scene.getBoundingClientRect();
    const cx = r.width/2, cy = r.height/2;
    map.view.x = cx - (n.x + n.w/2) * map.view.k;
    map.view.y = cy - (n.y + n.h/2) * map.view.k;
    applyTransform();
    positionCtx();
    autosave();
    setTool("select");
  }

  // ====== Header/project actions ======
  projectSelect.addEventListener("change", () => {
    setActiveProject(projectSelect.value);
  });

  document.getElementById("projNew").onclick = () => {
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –º–∞–π–Ω–¥–º—ç–ø–∞:", "–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    const p = createEmptyProject((name || "–ù–æ–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø").trim());
    rebuildProjectSelect();
    setActiveProject(p.id);
    showToast("–°–æ–∑–¥–∞–Ω–æ");
  };

  document.getElementById("projRename").onclick = () => {
    if (!active) return;
    const name = prompt("–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", active.name || "–ú–∞–π–Ω–¥–º—ç–ø");
    if (!name) return;
    active.name = name.trim();
    active.updatedAt = nowTs();
    saveStore();
    rebuildProjectSelect();
    showToast("–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ");
  };

  document.getElementById("projDup").onclick = () => {
    if (!active) return;
    const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–ø–∏–∏:", (active.name || "–ú–∞–π–Ω–¥–º—ç–ø") + " (–∫–æ–ø–∏—è)");
    const id = uid();
    const clone = {
      id,
      name: (name || "–ö–æ–ø–∏—è").trim(),
      createdAt: nowTs(),
      updatedAt: nowTs(),
      data: JSON.parse(JSON.stringify(active.data))
    };
    store.projects[id] = clone;
    store.activeId = id;
    saveStore();
    rebuildProjectSelect();
    setActiveProject(id);
    showToast("–î—É–±–ª–∏–∫–∞—Ç —Å–æ–∑–¥–∞–Ω");
  };

  document.getElementById("projDel").onclick = () => {
    if (!active) return;
    if (!confirm(`–£–¥–∞–ª–∏—Ç—å "${active.name}"?`)) return;

    delete store.projects[active.id];
    const ids = Object.keys(store.projects);
    if (!ids.length){
      createEmptyProject("–ú–æ–π –ø–µ—Ä–≤—ã–π –º–∞–π–Ω–¥–º—ç–ø");
    } else {
      store.activeId = ids[0];
    }
    saveStore();
    rebuildProjectSelect();
    setActiveProject(store.activeId);
    showToast("–£–¥–∞–ª–µ–Ω–æ");
  };

  document.getElementById("autoLayout").onclick = () => {
    if (!map.nodes.length){ showToast("–ù–µ—Ç —É–∑–ª–æ–≤"); return; }
    const root = map.nodes.find(n => !n.parentId) || map.nodes[0];
    const r = scene.getBoundingClientRect();
    const center = clientToWorld(r.left + r.width/2, r.top + r.height/2);

    root.x = center.x - root.w/2;
    root.y = center.y - root.h/2;

    const kids = childrenOf(root.id).map(getNode).filter(Boolean);
    let y = root.y - (kids.length * 76)/2;
    for (const k of kids){
      k.x = root.x + root.w + 160;
      k.y = y;
      y += 76;
    }
    autosave();
    renderAll();
    showToast("–ê–≤—Ç–æ-—Ä–∞—Å–∫–ª–∞–¥–∫–∞ –≥–æ—Ç–æ–≤–∞");
  };

  document.getElementById("resetView").onclick = () => {
    map.view = {x:24,y:24,k:1};
    applyTransform();
    positionCtx();
    autosave();
    showToast("–í–∏–¥ —Å–±—Ä–æ—à–µ–Ω");
  };

  // ====== Export/Import ======
  document.getElementById("exportOne").onclick = () => {
    if (!active) return;
    // Commit latest map into active first
    commitMap();
    const payload = {
      kind: "mindmap_project",
      version: 1,
      project: store.projects[store.activeId]
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    const safe = (active.name || "mindmap").replace(/[^\w\d\-_.]+/g,"_");
    a.download = safe + ".json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
  };

  importOne.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_project" || !obj.project) throw new Error("bad");
        const p = obj.project;
        if (!p.id) p.id = uid();
        p.data = normalizeMapData(p.data || {});
        p.createdAt ||= nowTs();
        p.updatedAt ||= nowTs();
        store.projects[p.id] = p;
        store.activeId = p.id;
        saveStore();
        rebuildProjectSelect();
        setActiveProject(p.id);
        showToast("–ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ");
      }catch(err){
        showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç—É");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
  });

  document.getElementById("exportAll").onclick = () => {
    commitMap();
    const payload = {
      kind: "mindmap_store",
      version: 1,
      store
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "mindmaps_all.json";
    a.click();
    URL.revokeObjectURL(a.href);
    showToast("–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –≥–æ—Ç–æ–≤");
  };

  importAll.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const fr = new FileReader();
    fr.onload = () => {
      try{
        const obj = JSON.parse(fr.result);
        if (!obj || obj.kind !== "mindmap_store" || !obj.store) throw new Error("bad");
        const s = obj.store;
        if (!s.projects || typeof s.projects !== "object") throw new Error("bad");
        // normalize all
        Object.values(s.projects).forEach(p => {
          if (!p.id) p.id = uid();
          p.name ||= "–ú–∞–π–Ω–¥–º—ç–ø";
          p.createdAt ||= nowTs();
          p.updatedAt ||= nowTs();
          p.data = normalizeMapData(p.data || {});
        });
        store = s;
        if (!store.activeId || !store.projects[store.activeId]){
          store.activeId = Object.keys(store.projects)[0];
        }
        saveStore();
        rebuildProjectSelect();
        setActiveProject(store.activeId);
        showToast("–ò–º–ø–æ—Ä—Ç –≤—Å–µ—Ö –≤—ã–ø–æ–ª–Ω–µ–Ω");
      }catch(err){
        showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –∫–∞—Ä—Ç—ã");
      }
    };
    fr.readAsText(f);
    e.target.value = "";
  });

  // ====== Shortcuts ======
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "v") setTool("select");
    if (k === "h") setTool("hand");
    if (k === "n") setTool("node");
    if (k === "c") setTool("center");

    if (e.ctrlKey && e.key === "/"){
      e.preventDefault();
      if (selectedId) toggleCollapse(selectedId);
    }

    if (e.key === "Tab" && selectedId && !editingId){
      e.preventDefault();
      addChildFrom(selectedId);
    }
    if (e.key === "Enter" && selectedId && !editingId){
      e.preventDefault();
      addSiblingFrom(selectedId);
    }
    if ((e.key === "Delete" || e.key === "Backspace") && selectedId && !editingId){
      e.preventDefault();
      deleteSubtree(selectedId);
    }
  });

  // ====== Fix collapse dot data attribute & render refinement ======
  // override renderNodes to mark dot for quick updates
  const _renderNodes = renderNodes;
  renderNodes = function(){
    nodesLayer.innerHTML = "";
    for (const n of map.nodes){
      if (isHiddenByCollapse(n.id)) continue;

      const div = document.createElement("div");
      div.className = "node" + (n.id === selectedId ? " selected" : "");
      div.style.left = n.x + "px";
      div.style.top  = n.y + "px";
      div.style.width = n.w + "px";
      div.style.height = n.h + "px";
      div.style.background = n.style?.fill || "rgba(255,255,255,.80)";
      div.style.borderColor = n.style?.stroke || "rgba(11,19,36,.18)";
      div.setAttribute("data-id", n.id);

      const icon = document.createElement("div");
      icon.className = "icon";
      icon.textContent = n.icon || "";

      const text = document.createElement("div");
      text.className = "text";
      text.textContent = n.text || "";

      div.appendChild(icon);
      div.appendChild(text);

      div.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (editingId) return;

        selectedId = n.id;
        renderSelectionOnly();
        positionCtx();

        drag = {
          kind: "node",
          pointerId: e.pointerId,
          sx: e.clientX, sy: e.clientY,
          moved: false,
          baseX: n.x, baseY: n.y
        };
        div.setPointerCapture(e.pointerId);
      });

      div.addEventListener("pointerup", (e) => {
        e.stopPropagation();
        if (editingId) return;
        if (drag && drag.kind === "node" && drag.pointerId === e.pointerId && drag.moved) return;

        const now = Date.now();
        const same = (tap.id === n.id) && (now - tap.t <= TAP_WINDOW);
        tap.id = n.id;
        tap.t = now;
        tap.count = same ? (tap.count + 1) : 1;

        if (tap.timer) clearTimeout(tap.timer);
        tap.timer = setTimeout(() => {
          if (tap.id !== n.id) return;
          if (tap.count === 2) addChildFrom(n.id);
          else if (tap.count >= 3) beginEdit(n.id);
          tap.id = null; tap.count = 0; tap.timer = null;
        }, TAP_WINDOW + 30);
      });

      nodesLayer.appendChild(div);

      const kids = childrenOf(n.id);
      if (kids.length){
        const dot = document.createElement("div");
        dot.className = "collapseDot";
        dot.setAttribute("data-dot-for", n.id);
        dot.style.left = (n.x + n.w + 10) + "px";
        dot.style.top  = (n.y + n.h/2 - 11) + "px";
        dot.textContent = n.collapsed ? "+" : "‚Äì";
        dot.title = n.collapsed ? "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å" : "–°–≤–µ—Ä–Ω—É—Ç—å";
        dot.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleCollapse(n.id);
        });
        nodesLayer.appendChild(dot);
      }
    }
  };

  // ====== Start ======
  init();
})();
</script>
</body>
</html>
